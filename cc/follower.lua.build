function MODULE_utils_other_file()
	return {
	    readText = function (path)
	        local file = fs.open(path, "r")
	        if file == nil then
	            return nil
	        end
	        local content = file.readAll()
	        file.close()
	        return content
	    end,
	    writeText = function (path, content)
	        local file = fs.open(path, "w")
	        file.write(content)
	        file.close()
	    end,
	}
end
local utils_other_file = MODULE_utils_other_file()


function MODULE_jobs_Job()
	local Job = {}
	Job.EXAMPLE = "ExampleJob"
	Job.IDLE = "IdleJob"
	Job.SETUP = "SetupJob"
	Job.TEST_JOB = "TestJob"
	Job.PROGRAMMABLE_JOB = "ProgrammableJob"
	Job.QUARRY = "QuarryJob"
	Job.TREE_FARM = "TreeFarmJob"
	Job.FOLLOWER_JOB = "FollowerJob"
	Job.STORAGE = "StorageJob"
	Job.TABLET_CONTROLLER = "TabletControllerJob"
	Job.SCANNER = "ScannerJob"
	return Job
end
local jobs_Job = MODULE_jobs_Job()


function MODULE_utils_config_JobConfig()
	local file = utils_other_file
	local Job       = jobs_Job
	local JobConfig = {}
	JobConfig.__index = JobConfig
	function JobConfig.new()
	    local self = setmetatable({
	        name = "My Computer",
	        job = Job.IDLE,
	        state = {},  -- Data specific to a job that is saved between runs
	    }, JobConfig)
	    return self
	end
	function JobConfig.fromTable(table)
	    local self = JobConfig.new()
	    self.name = table.name or self.name
	    self.job = table.job or self.job
	    self.state = table.state or self.state
	    return self
	end
	function JobConfig:toTable()
	    return {
	        name = self.name,
	        job = self.job,
	        state = self.state,
	    }
	end
	function JobConfig:serializeJson()
	    return textutils.serialize(self:toTable())
	end
	function JobConfig.deserializeJson(json)
	    local success, configAttributes = pcall(textutils.unserialize, json)
	    if not success or configAttributes == nil then
	        configAttributes = textutils.unserializeJSON(json)
	    end
	    local config = JobConfig.fromTable(configAttributes)
	    return config
	end
	function JobConfig:save()
	    file.writeText("job.json", self:serializeJson())
	end
	function JobConfig.load()
	    local config = nil
	    local content = file.readText("job.json")
	    if content == nil then
	        config = JobConfig.new()
	    else
	        config = JobConfig.deserializeJson(content)
	    end
	    config:save()  -- Save any default values that were missing
	    return config
	end
	function JobConfig:get(key, defaultValue)
	    return self.state[key] or defaultValue
	end
	function JobConfig:set(key, value)
	    self.state[key] = value
	    self:save()
	end
	function JobConfig:init(key, defaultValue)
	    if self:get(key, nil) == nil then
	        self:set(key, defaultValue)
	    end
	end
	function JobConfig:getNext(key, defaultValue)
	    local list = self:get(key, {})
	    if #list == 0 then
	        return defaultValue
	    end
	    local value = table.remove(list, 1)
	    if #list > 0 then
	        self:set(key, list)
	    else
	        self:set(key, nil)
	    end
	    return value
	end
	function JobConfig:dequeue(key, defaultValue)
	    return self:getNext(key, defaultValue)
	end
	function JobConfig:enqueue(key, value)
	    local list = self:get(key, {})
	    table.insert(list, value)
	    self:set(key, list)
	end
	return JobConfig
end
local utils_config_JobConfig = MODULE_utils_config_JobConfig()


function MODULE_utils_controlflow_Parallel()
	local Parallel = {}
	Parallel.__index = Parallel
	Parallel.CHUNK_SIZE = 48
	function Parallel.new()
	    local self = setmetatable({}, Parallel)
	    self.tasks = {}
	    return self
	end
	function Parallel:addTask(task)
	    table.insert(self.tasks, task)
	    return self
	end
	function Parallel:addTimeout(timeoutSeconds)
	    table.insert(self.tasks, function() os.sleep(timeoutSeconds) end)
	    return self
	end
	function Parallel:run()
	    parallel.waitForAll(table.unpack(self.tasks))
	    return self
	end
	function Parallel:waitForAny()
	    parallel.waitForAny(table.unpack(self.tasks))
	    return self
	end
	function Parallel:waitForAll()
	    parallel.waitForAll(table.unpack(self.tasks))
	    return self
	end
	function Parallel.map(obj, func)
	    if type(obj) == "table" then
	        if #obj > 0 then
	            return Parallel.mapList(obj, func)
	        else
	            return Parallel.mapTable(obj, func)
	        end
	    else
	        return Parallel.mapList(obj, func)
	    end
	end
	local function getChunks(list, chunkSize)
	    local chunks = {}
	    for i = 1, chunkSize do
	        chunks[i] = {}
	    end
	    for i, item in ipairs(list) do
	        table.insert(chunks[(i - 1) % chunkSize + 1], item)
	    end
	    return chunks
	end
	local function getChunksMap(map, chunkSize)
	    local chunks = {}
	    for i = 1, chunkSize do
	        chunks[i] = {}
	    end
	    local keys = {}
	    for key, _ in pairs(map) do
	        table.insert(keys, key)
	    end
	    for i, key in ipairs(keys) do
	        table.insert(chunks[(i - 1) % chunkSize + 1], key)
	    end
	    return chunks
	end
	function Parallel.mapList(list, func, output)
	    output = output or {}
	    local parallel = Parallel.new()
	    local chunks = getChunks(list, Parallel.CHUNK_SIZE)
	    for i, chunk in ipairs(chunks) do
	        parallel:addTask(function()
	            for index, item in ipairs(chunk) do
	                if item ~= nil then
	                    local elementResult = func(item)
	                    output[(i - 1) * Parallel.CHUNK_SIZE + index] = elementResult
	                end
	            end
	        end)
	    end
	    parallel:run()
	    return output
	end
	function Parallel.mapTable(table_, func, output)
	    output = output or {}
	    local parallel = Parallel.new()
	    local chunks = getChunksMap(table_, Parallel.CHUNK_SIZE)
	    for i, chunk in ipairs(chunks) do
	        parallel:addTask(function()
	            for _, key in ipairs(chunk) do
	                local item = table_[key]
	                if item ~= nil then
	                    local elementResult = func(key, item)
	                    output[key] = elementResult
	                end
	            end
	        end)
	    end
	    parallel:run()
	    return output
	end
	function Parallel.mapListWithTimeout(obj, func, timeoutSeconds)
	    timeoutSeconds = timeoutSeconds or 1
	    local output = {}
	    local function applyFuncToObjItems()
	        output = Parallel.mapList(obj, func, output)
	    end
	    Parallel.new()
	        :addTask(applyFuncToObjItems)
	        :addTimeout(timeoutSeconds)
	        :waitForAny()
	    return output
	end
	function Parallel.mapTableWithTimeout(obj, func, timeoutSeconds)
	    timeoutSeconds = timeoutSeconds or 1
	    local output = {}
	    local function applyFuncToObjItems()
	        output = Parallel.mapTable(obj, func, output)
	    end
	    Parallel.new()
	        :addTask(applyFuncToObjItems)
	        :addTimeout(timeoutSeconds)
	        :waitForAny()
	    return output
	end
	function Parallel.mapDictWithTimeout(dict, func, timeoutSeconds)
	    return Parallel.mapTableWithTimeout(dict:toTable(), func, timeoutSeconds)
	end
	return Parallel
end
local utils_controlflow_Parallel = MODULE_utils_controlflow_Parallel()


function MODULE_utils_libs_LibOs()
	local LibOs = {}
	function LibOs.getComputerID()
	    return os.getComputerID()
	end
	function LibOs.getComputerLabel()
	    return os.getComputerLabel()
	end
	function LibOs.setComputerLabel(label)
	    return os.setComputerLabel(label)
	end
	function LibOs.sleep(time)
	    os.sleep(time)
	end
	function LibOs.pullEvent(filter)
	    return os.pullEvent(filter)
	end
	function LibOs.queueEvent(name, ...)
	    return os.queueEvent(name, ...)
	end
	function LibOs.run(env, path, ...)
	    return os.run(env, path, ...)
	end
	function LibOs.version()
	    return os.version()
	end
	function LibOs.shutdown()
	    return os.shutdown()
	end
	function LibOs.reboot()
	    return os.reboot()
	end
	function LibOs.getSecondsSinceComputerStart()
	    return os.clock()
	end
	function LibOs.time(locale)
	    return os.time(locale)
	end
	function LibOs.date(format, time)
	    return os.date(format, time)
	end
	function LibOs.day(...)
	    return os.day(...)
	end
	function LibOs.epoch(...)
	    return os.epoch(...)
	end
	return LibOs
end
local utils_libs_LibOs = MODULE_utils_libs_LibOs()


function MODULE_utils_network_Network()
	local Parallel = utils_controlflow_Parallel
	local LibOs = utils_libs_LibOs
	local Network = {}
	peripheral.find("modem", rednet.open)
	function Network.postResponse(protocol, commandName, response)
	    protocol.responses = protocol.responses or {}
	    protocol.responses[commandName] = response
	end
	function Network.waitForResponse(protocol, commandName)
	    protocol.responses = protocol.responses or {}
	    protocol.responses[commandName] = false
	    local timeout = 10
	    local sleepTime = 0.05
	    while protocol.responses[commandName] == false do
	        LibOs.sleep(sleepTime)
	        timeout = timeout - sleepTime
	        if timeout <= 0 then
	            protocol.responses[commandName] = {isSuccess = false, message = "Timeout"}
	            break
	        end
	    end
	    local response = protocol.responses[commandName]
	    protocol.responses[commandName] = nil
	    return response
	end
	function Network.isOpen()
	    return rednet.isOpen()
	end
	function Network.host(protocol, hostname)
	    if not Network.isOpen() then return print("Network is not open") end
	    hostname = hostname or ("computer:" .. LibOs.getComputerID())
	    rednet.host(protocol, hostname)
	end
	function Network.lookup(protocol, hostname)
	    if not Network.isOpen() then return print("Network is not open") end
	    return rednet.lookup(protocol, hostname)
	end
	function Network.unhost(protocol)
	    if not Network.isOpen() then return print("Network is not open") end
	    rednet.unhost(protocol)
	end
	function Network.listenWithProtocols(protocols)
	    if not Network.isOpen() then return print("Network is not open") end
	    Parallel.map(protocols, function(key, protocol) protocol:listen() end)
	end
	function Network.listen(protocol, timeout, func)
	    if not Network.isOpen() then return print("Network is not open") end
	    while true do
	        local senderId, message = rednet.receive(protocol, timeout)
	        func(senderId, message)
	    end
	end
	function Network.send(recipient, message, protocol)
	    if not Network.isOpen() then return print("Network is not open") end
	    rednet.send(recipient, message, protocol)
	end
	function Network.broadcast(message, protocol)
	    if not Network.isOpen() then return print("Network is not open") end
	    rednet.broadcast(message, protocol)
	end
	return Network
end
local utils_network_Network = MODULE_utils_network_Network()


function MODULE_utils_terminal_Terminal()
	local LibOs = utils_libs_LibOs
	local Terminal = {}
	Terminal.__index = Terminal
	function Terminal.clear()
	    term.clear()
	    term.setCursorPos(1, 1)
	end
	function Terminal.waitForKey()
	    local _, key = LibOs.pullEvent("key")
	    return key
	end
	function Terminal.writeLineBreak()
	    print("-------------------------")
	end
	function Terminal.write(text)
	    print(text)
	end
	function Terminal.read(prompt)
	    if prompt ~= nil then
	        write(prompt)
	    end
	    return read()
	end
	function Terminal.readNumber(prompt)
	    local value = nil
	    while value == nil do
	        local input = Terminal.read(prompt)
	        value = tonumber(input)
	    end
	    return value
	end
	function Terminal.readBoolean(prompt)
	    local value = nil
	    while value == nil do
	        local input = Terminal.read(prompt):lower()
	        if input == "true" or input == "y" or input == "yes" then
	            value = true
	        elseif input == "false" or input == "n" or input == "no" then
	            value = false
	        end
	    end
	    return value
	end
	function Terminal.readTable(prompt, requiredFields)
	    local value = nil
	    local validationPassed = false
	    while validationPassed == false do
	        local input = Terminal.read(prompt)
	        value = textutils.unserialize(input)
	        if value ~= nil then
	            validationPassed = true
	            for key, _ in pairs(requiredFields) do
	                if value[key] == nil then
	                    validationPassed = false
	                    Terminal.write("\t\tMissing field: '" .. key .. "'")
	                end
	            end
	            if not validationPassed then
	                Terminal.write("\t\tExpected format: " .. textutils.serialize(requiredFields))
	            end
	        end
	    end
	    return value or {}
	end
	return Terminal
end
local utils_terminal_Terminal = MODULE_utils_terminal_Terminal()


function MODULE_jobs_JobManager()
	local JobConfig = utils_config_JobConfig
	local Network = utils_network_Network
	local Parallel = utils_controlflow_Parallel
	local LibOs = utils_libs_LibOs
	local Job = jobs_Job
	local Terminal = utils_terminal_Terminal
	local JobManager = {}
	function JobManager.run(jobClass)
	    local config = JobConfig.load()
	    config.job = jobClass.name
	    config:save()
	    if config:get("username", nil) == nil then
	        config:set("username", Terminal.read("Enter your username: "))
	    end
	    local job = jobClass.new(config)
	    if jobClass.name == Job.TABLET_CONTROLLER then
	        job.name = config:get("username", "Unknown User")
	    else
	        job.name = jobClass.name .. ":" .. LibOs.getComputerID()
	    end
	    job.log = function(...) print(...) job.logSilent(...) end
	    job.logSilent = function(...) if job.protocols ~= nil and job.protocols.log ~= nil then job.protocols.log:sendLog(...) end end
	    job.logToChannel = function(channel, ...) if job.protocols ~= nil and job.protocols.log ~= nil then job.protocols.log:sendLogToChannel(channel, ...) end end
	    if job == nil then
	        print("Job not found: " .. jobClass.name)
	        return
	    end
	    print("Starting Job: " .. jobClass.name)
	    job:onStart()
	    local p = Parallel.new()
	    p:addTask(function() JobManager.runForegroundTask(job, config, jobClass.name) end)
	    if job.protocols ~= nil then
	        if Network.isOpen() then
	            p:addTask(function() Network.listenWithProtocols(job.protocols) end)
	        else
	            print("Network is not open - cannot use protocols defined for job")
	        end
	    end
	    if job.backgroundTasks ~= nil then
	        for _, backgroundTask in ipairs(job.backgroundTasks) do
	            p:addTask(function() backgroundTask(job, config) end)
	        end
	    end
	    if job.backgroundTask ~= nil then
	        p:addTask(function() JobManager.runBackgroundTask(job, config) end)
	    end
	    p:waitForAny()
	    job:onComplete()
	    print("Completed Job: " .. jobClass.name)
	    config:save()
	end
	function JobManager.runForegroundTask(job, config, name)
	    print("Running Job: " .. name)
	    while job:inProgress() do
	        job:onStep()
	    end
	end
	function JobManager.runBackgroundTask(job, config)
	    if job.backgroundTask == nil then
	        return
	    end
	    if job.backgroundDelay == nil then
	        error("Background task defined without a job.backgroundDelay")
	    end
	    while job:inProgress() do
	        job.backgroundTask()
	        if job.backgroundDelay > 0 then
	            os.sleep(job.backgroundDelay)
	        end
	    end
	end
	return JobManager
end
local jobs_JobManager = MODULE_jobs_JobManager()


function MODULE_utils_terminal_commands_Command()
	local Command = {}
	Command.__index = Command
	function Command.new(name, helpText, func)
	    local self = setmetatable({}, Command)
	    self.name = name
	    self.helpText = helpText
	    self.func = func
	    return self
	end
	function Command:help()
	    print("Command: " .. self.name)
	    print(self.helpText)
	end
	function Command:run(...)
	    self.func(...)
	end
	return Command
end
local utils_terminal_commands_Command = MODULE_utils_terminal_commands_Command()


function MODULE_utils_data_Table()
	local Table = {}
	function Table.map(object, func)
	    local newObject = {}
	    for key, value in pairs(object) do
	        newObject[key] = func(value)
	    end
	    return newObject
	end
	function Table.filter(object, func)
	    local newObject = {}
	    for key, value in pairs(object) do
	        if func(value) then
	            table.insert(newObject, value)
	        end
	    end
	    return newObject
	end
	function Table.any(object, func)
	    for _, value in ipairs(object) do
	        if func(value) then
	            return true
	        end
	    end
	    return false
	end
	function Table.all(object, func)
	    for _, value in ipairs(object) do
	        if not func(value) then
	            return false
	        end
	    end
	    return true
	end
	function Table.contains(object, value)
	    for _, v in ipairs(object) do
	        if v == value then
	            return true
	        end
	    end
	    return false
	end
	function Table.size(object)
	    local count = 0
	    for _ in pairs(object) do count = count + 1 end
	    return count
	end
	function Table.isEmpty(object)
	    return next(object) == nil
	end
	function Table.copy(object)
	    local newObject = {}
	    for key, value in pairs(object) do
	        newObject[key] = value
	    end
	    return newObject
	end
	function Table.addAll(object, other)
	    object = object or {}
	    other = other or {}
	    for _, value in ipairs(other) do
	        table.insert(object, value)
	    end
	end
	function Table.unique(object)
	    local unique = {}
	    for _, value in ipairs(object) do
	        if not Table.contains(unique, value) then
	            table.insert(unique, value)
	        end
	    end
	    return unique
	end
	function Table.intersection(first, second)
	    local intersection = {}
	    first = Table.unique(first)
	    second = Table.unique(second)
	    for _, value in ipairs(first) do
	        if Table.contains(second, value) then
	            table.insert(intersection, value)
	        end
	    end
	    return intersection
	end
	function Table.union(first, second)
	    local union = Table.copy(first)
	    Table.addAll(union, second)
	    union = Table.unique(union)
	    return union
	end
	function Table.difference(first, second)
	    local difference = {}
	    first = Table.unique(first)
	    second = Table.unique(second)
	    for _, value in ipairs(first) do
	        if not Table.contains(second, value) then
	            table.insert(difference, value)
	        end
	    end
	    return difference
	end
	return Table
end
local utils_data_Table = MODULE_utils_data_Table()


function MODULE_utils_text_Text()
	local Table = utils_data_Table
	local Text = {}
	function Text.contains(text, pattern)
	    if type(pattern) == "table" then
	        return Table.any(pattern, function(subPattern)
	            return Text.contains(text, subPattern)
	        end)
	    else
	        return text:find(pattern) ~= nil
	    end
	end
	function Text.startsWith(text, pattern)
	    return text:sub(1, #pattern) == pattern
	end
	function Text.endsWith(text, pattern)
	    return text:sub(-#pattern) == pattern
	end
	function Text.split(input, delimiter)
	    local result = {}
	    for match in (input .. delimiter):gmatch("(.-)" .. delimiter) do
	        table.insert(result, match)
	    end
	    return result
	end
	function Text.getDisplayName(minecraftName)
	    local displayName = minecraftName
	    local parts = Text.split(displayName, ":")
	    if #parts == 2 then
	        displayName = parts[2]
	    end
	    displayName = displayName:gsub("_", " ")
	    displayName = displayName:gsub("(%l)(%w*)", function(a,b) return string.upper(a)..b end)
	    return displayName
	end
	function Text.levenshtein(str1, str2)
	    local len1, len2 = #str1, #str2
	    local matrix = {}
	    for i = 0, len1 do
	        matrix[i] = { [0] = i }
	    end
	    for j = 0, len2 do
	        matrix[0][j] = j
	    end
	    for i = 1, len1 do
	        for j = 1, len2 do
	            local cost = (str1:sub(i, i) == str2:sub(j, j)) and 0 or 1
	            matrix[i][j] = math.min(
	                matrix[i - 1][j] + 1,    -- deletion
	                matrix[i][j - 1] + 1,    -- insertion
	                matrix[i - 1][j - 1] + cost -- substitution
	            )
	        end
	    end
	    return matrix[len1][len2]
	end
	function Text.simplifyIdentifier(id)
	    id = id:match(":(.*)") or id
	    id = id:gsub("_", " ") or id
	    return id
	end
	function Text.getClosestMatch(input, identifiers)
	    local bestMatch = nil
	    local bestScore = math.huge
	    for _, id in pairs(identifiers) do
	        local simplifiedId = Text.simplifyIdentifier(id)
	        local score = Text.levenshtein(input, simplifiedId)
	        if score < bestScore then
	            bestScore = score
	            bestMatch = id
	        end
	    end
	    return bestMatch, bestScore
	end
	function Text.getClosestMatchingGroup(input, identifierGroups)
	    local bestMatch = nil
	    local bestScore = math.huge
	    for id, group in pairs(identifierGroups) do
	        local score = Text.levenshtein(input, id)
	        if score < bestScore then
	            bestScore = score
	            bestMatch = group
	        end
	    end
	    return bestMatch, bestScore
	end
	return Text
end
local utils_text_Text = MODULE_utils_text_Text()


function MODULE_utils_terminal_commands_Commands()
	local Command = utils_terminal_commands_Command
	local Text = utils_text_Text
	local Commands = {}
	Commands.__index = Commands
	function Commands.new()
	    local self = setmetatable({}, Commands)
	    self.commands = {}
	    self:add("help", Command.new("help", "Prints a list of commands", function(...) self:help(...) end))
	    return self
	end
	function Commands:add(name, command)
	    if name ~= nil and command ~= nil then
	        self.commands[name] = command
	    elseif name ~= nil and command == nil then
	        command = name
	        self.commands[command.name] = command
	    elseif name == nil and command == nil then
	        print("'Commands:add' provided both name and command = nil")
	    else
	        print("How did this happen?")
	    end
	end
	function Commands:help(commandName)
	    if commandName ~= nil then
	        local command = self.commands[commandName]
	        if command == nil then
	            print("Command not found: " .. commandName)
	            return
	        end
	        command:help()
	        return
	    end
	    print("Commands:")
	    for name, command in pairs(self.commands) do
	        print("  " .. name)
	    end
	    print("*Type 'help <command>' for more information")
	end
	function Commands:run(message)
	    if message == nil or message == "" then
	        print("No command entered")
	        print("Type 'help' for a list of commands")
	        return
	    end
	    local parts = Text.split(message, " ")
	    local name = parts[1]
	    local command = self.commands[name]
	    if command == nil then
	        print("Command not found '" .. message .. "'")
	        print("\ttype 'help' for a list of commands")
	        return
	    end
	    local arguments = {}
	    for i = 2, #parts do
	        table.insert(arguments, parts[i])
	    end
	    command:run(table.unpack(arguments))
	end
	return Commands
end
local utils_terminal_commands_Commands = MODULE_utils_terminal_commands_Commands()


function MODULE_jobs_definitions_mobile_treeFarm_TreeFarmCommands()
	local TreeFarmCommands = {}
	function TreeFarmCommands.commandTreeFarmStart(self)
	    self.log("Starting the tree farm")
	    self.config:set("state", self.states.TREE_FARM_STARTING)
	end
	return TreeFarmCommands
end
local jobs_definitions_mobile_treeFarm_TreeFarmCommands = MODULE_jobs_definitions_mobile_treeFarm_TreeFarmCommands()


function MODULE_utils_jobutils_CommonCommands()
	local CommonCommands = {}
	function CommonCommands.commandExit(self)
	    self.config:set("alive", false)
	end
	function CommonCommands.commandSetup(self)
	    print("Entering setup mode")
	    self.config:set("state", self.states.SETUP)
	end
	return CommonCommands
end
local utils_jobutils_CommonCommands = MODULE_utils_jobutils_CommonCommands()


function MODULE_turtle_Side()
	local Side = {}
	Side.TOP = "top"
	Side.BOTTOM = "bottom"
	Side.FRONT = "front"
	Side.BACK = "back"
	Side.LEFT = "left"
	Side.RIGHT = "right"
	return Side
end
local turtle_Side = MODULE_turtle_Side()


function MODULE_utils_storage_patterns_ContainerPatternNames()
	local Side = turtle_Side
	local ContainerPatternNames = {}
	ContainerPatternNames.DIRECTION_UP = Side.TOP
	ContainerPatternNames.DIRECTION_DOWN = Side.BOTTOM
	ContainerPatternNames.DIRECTION_FORWARD = Side.FRONT
	ContainerPatternNames.DIRECTION_BACK = Side.BACK
	ContainerPatternNames.DIRECTION_LEFT = Side.LEFT
	ContainerPatternNames.DIRECTION_RIGHT = Side.RIGHT
	ContainerPatternNames.ACTION_STOP = "ACTION_STOP"
	ContainerPatternNames.ACTION_HOME = "ACTION_HOME"
	ContainerPatternNames.ACTION_MOVE = "ACTION_MOVE"
	ContainerPatternNames.ACTION_BREAK = "ACTION_BREAK"
	ContainerPatternNames.ACTION_PLACE = "ACTION_PLACE"
	ContainerPatternNames.ACTION_MARKER = "ACTION_MARKER"
	ContainerPatternNames.ACTION_DROP = "ACTION_DROP"
	ContainerPatternNames.ACTION_SUCK = "ACTION_SUCK"
	ContainerPatternNames.ACTION_REFUEL = "ACTION_REFUEL"
	return ContainerPatternNames
end
local utils_storage_patterns_ContainerPatternNames = MODULE_utils_storage_patterns_ContainerPatternNames()


function MODULE_utils_blocks_Blocks()
	local Blocks = {
	    ANY = "any",
	    stone = "minecraft:stone",
	    iron_ore = "minecraft:iron_ore",
	    gold_ore = "minecraft:gold_ore",
	    diamond_ore = "minecraft:diamond_ore",
	    emerald_ore = "minecraft:emerald_ore",
	    redstone_ore = "minecraft:redstone_ore",
	    lapis_ore = "minecraft:lapis_ore",
	    coal_ore = "minecraft:coal_ore",
	    copper_ore = "minecraft:copper_ore",
	    copper_block = "minecraft:copper_block",
	    copper_ingot = "minecraft:copper_ingot",
	    copper_nugget = "minecraft:copper_nugget",
	    iron_nugget = "minecraft:iron_nugget",
	    gold_nugget = "minecraft:gold_nugget",
	    diamond = "minecraft:diamond",
	    emerald = "minecraft:emerald",
	    redstone = "minecraft:redstone",
	    lapis = "minecraft:lapis",
	    deepslate_iron_ore = "minecraft:deepslate_iron_ore",
	    deepslate_gold_ore = "minecraft:deepslate_gold_ore",
	    deepslate_diamond_ore = "minecraft:deepslate_diamond_ore",
	    deepslate_emerald_ore = "minecraft:deepslate_emerald_ore",
	    deepslate_redstone_ore = "minecraft:deepslate_redstone_ore",
	    deepslate_lapis_ore = "minecraft:deepslate_lapis_ore",
	    deepslate_coal_ore = "minecraft:deepslate_coal_ore",
	    deepslate_copper_ore = "minecraft:deepslate_copper_ore",
	    ancient_debris = "minecraft:ancient_debris",
	    netherite_ingot = "minecraft:netherite_ingot",
	    netherite_block = "minecraft:netherite_block",
	    netherite_scrap = "minecraft:netherite_scrap",
	    netherite_sword = "minecraft:netherite_sword",
	    netherite_pickaxe = "minecraft:netherite_pickaxe",
	    netherite_axe = "minecraft:netherite_axe",
	    netherite_shovel = "minecraft:netherite_shovel",
	    netherite_hoe = "minecraft:netherite_hoe",
	    netherite_helmet = "minecraft:netherite_helmet",
	    netherite_chestplate = "minecraft:netherite_chestplate",
	    netherite_leggings = "minecraft:netherite_leggings",
	    netherite_boots = "minecraft:netherite_boots",
	    iron_sword = "minecraft:iron_sword",
	    iron_pickaxe = "minecraft:iron_pickaxe",
	    iron_axe = "minecraft:iron_axe",
	    iron_shovel = "minecraft:iron_shovel",
	    iron_hoe = "minecraft:iron_hoe",
	    iron_helmet = "minecraft:iron_helmet",
	    iron_chestplate = "minecraft:iron_chestplate",
	    iron_leggings = "minecraft:iron_leggings",
	    iron_boots = "minecraft:iron_boots",
	    gold_sword = "minecraft:gold_sword",
	    gold_pickaxe = "minecraft:gold_pickaxe",
	    gold_axe = "minecraft:gold_axe",
	    gold_shovel = "minecraft:gold_shovel",
	    gold_hoe = "minecraft:gold_hoe",
	    gold_helmet = "minecraft:gold_helmet",
	    gold_chestplate = "minecraft:gold_chestplate",
	    gold_leggings = "minecraft:gold_leggings",
	    gold_boots = "minecraft:gold_boots",
	    diamond_sword = "minecraft:diamond_sword",
	    diamond_pickaxe = "minecraft:diamond_pickaxe",
	    diamond_axe = "minecraft:diamond_axe",
	    diamond_shovel = "minecraft:diamond_shovel",
	    diamond_hoe = "minecraft:diamond_hoe",
	    diamond_helmet = "minecraft:diamond_helmet",
	    diamond_chestplate = "minecraft:diamond_chestplate",
	    diamond_leggings = "minecraft:diamond_leggings",
	    diamond_boots = "minecraft:diamond_boots",
	    iron_block = "minecraft:iron_block",
	    gold_block = "minecraft:gold_block",
	    diamond_block = "minecraft:diamond_block",
	    emerald_block = "minecraft:emerald_block",
	    redstone_block = "minecraft:redstone_block",
	    lapis_block = "minecraft:lapis_block",
	    coal_block = "minecraft:coal_block",
	    coal = "minecraft:coal",
	    charcoal = "minecraft:charcoal",
	    charcoal_block = "minecraft:charcoal_block",
	    chest = "minecraft:chest",
	    barrel = "minecraft:barrel",
	    furnace = "minecraft:furnace",
	    crafting_table = "minecraft:crafting_table",
	    anvil = "minecraft:anvil",
	    enchanting_table = "minecraft:enchanting_table",
	    brewing_stand = "minecraft:brewing_stand",
	    blast_furnace = "minecraft:blast_furnace",
	    smoker = "minecraft:smoker",
	    loom = "minecraft:loom",
	    cartography_table = "minecraft:cartography_table",
	    stonecutter = "minecraft:stonecutter",
	    grindstone = "minecraft:grindstone",
	    smithing_table = "minecraft:smithing_table",
	    lectern = "minecraft:lectern",
	    beehive = "minecraft:beehive",
	    bee_nest = "minecraft:bee_nest",
	    composter = "minecraft:composter",
	    bell = "minecraft:bell",
	    jukebox = "minecraft:jukebox",
	    note_block = "minecraft:note_block",
	    end_portal_frame = "minecraft:end_portal_frame",
	    end_portal = "minecraft:end_portal",
	    end_gateway = "minecraft:end_gateway",
	    stick = "minecraft:stick",
	    oak_planks = "minecraft:oak_planks",
	    spruce_planks = "minecraft:spruce_planks",
	    birch_planks = "minecraft:birch_planks",
	    jungle_planks = "minecraft:jungle_planks",
	    acacia_planks = "minecraft:acacia_planks",
	    dark_oak_planks = "minecraft:dark_oak_planks",
	    crimson_planks = "minecraft:crimson_planks",
	    warped_planks = "minecraft:warped_planks",
	    oak_log = "minecraft:oak_log",
	    spruce_log = "minecraft:spruce_log",
	    birch_log = "minecraft:birch_log",
	    jungle_log = "minecraft:jungle_log",
	    acacia_log = "minecraft:acacia_log",
	    dark_oak_log = "minecraft:dark_oak_log",
	    mangrove_log = "minecraft:mangrove_log",
	    crimson_stem = "minecraft:crimson_stem",
	    warped_stem = "minecraft:warped_stem",
	    oak_wood = "minecraft:oak_wood",
	    spruce_wood = "minecraft:spruce_wood",
	    birch_wood = "minecraft:birch_wood",
	    jungle_wood = "minecraft:jungle_wood",
	    acacia_wood = "minecraft:acacia_wood",
	    dark_oak_wood = "minecraft:dark_oak_wood",
	    crimson_hyphae = "minecraft:crimson_hyphae",
	    warped_hyphae = "minecraft:warped_hyphae",
	    oak_leaves = "minecraft:oak_leaves",
	    spruce_leaves = "minecraft:spruce_leaves",
	    birch_leaves = "minecraft:birch_leaves",
	    jungle_leaves = "minecraft:jungle_leaves",
	    acacia_leaves = "minecraft:acacia_leaves",
	    dark_oak_leaves = "minecraft:dark_oak_leaves",
	    mangrove_leaves = "minecraft:mangrove_leaves",
	    crimson_leaves = "minecraft:crimson_leaves",
	    warped_leaves = "minecraft:warped_leaves",
	    oak_sapling = "minecraft:oak_sapling",
	    spruce_sapling = "minecraft:spruce_sapling",
	    birch_sapling = "minecraft:birch_sapling",
	    jungle_sapling = "minecraft:jungle_sapling",
	    acacia_sapling = "minecraft:acacia_sapling",
	    dark_oak_sapling = "minecraft:dark_oak_sapling",
	    mangrove_sapling = "minecraft:mangrove_sapling",
	    crimson_fungus = "minecraft:crimson_fungus",
	    warped_fungus = "minecraft:warped_fungus",
	    oak_fence = "minecraft:oak_fence",
	    spruce_fence = "minecraft:spruce_fence",
	    birch_fence = "minecraft:birch_fence",
	    jungle_fence = "minecraft:jungle_fence",
	    acacia_fence = "minecraft:acacia_fence",
	    dark_oak_fence = "minecraft:dark_oak_fence",
	    crimson_fence = "minecraft:crimson_fence",
	    warped_fence = "minecraft:warped_fence",
	    oak_fence_gate = "minecraft:oak_fence_gate",
	    spruce_fence_gate = "minecraft:spruce_fence_gate",
	    birch_fence_gate = "minecraft:birch_fence_gate",
	    jungle_fence_gate = "minecraft:jungle_fence_gate",
	    acacia_fence_gate = "minecraft:acacia_fence_gate",
	    dark_oak_fence_gate = "minecraft:dark_oak_fence_gate",
	    crimson_fence_gate = "minecraft:crimson_fence_gate",
	    warped_fence_gate = "minecraft:warped_fence_gate",
	    oak_stairs = "minecraft:oak_stairs",
	    spruce_stairs = "minecraft:spruce_stairs",
	    birch_stairs = "minecraft:birch_stairs",
	    jungle_stairs = "minecraft:jungle_stairs",
	    acacia_stairs = "minecraft:acacia_stairs",
	    dark_oak_stairs = "minecraft:dark_oak_stairs",
	    crimson_stairs = "minecraft:crimson_stairs",
	    warped_stairs = "minecraft:warped_stairs",
	    oak_slab = "minecraft:oak_slab",
	    spruce_slab = "minecraft:spruce_slab",
	    birch_slab = "minecraft:birch_slab",
	    jungle_slab = "minecraft:jungle_slab",
	    acacia_slab = "minecraft:acacia_slab",
	    dark_oak_slab = "minecraft:dark_oak_slab",
	    crimson_slab = "minecraft:crimson_slab",
	    warped_slab = "minecraft:warped_slab",
	    oak_button = "minecraft:oak_button",
	    spruce_button = "minecraft:spruce_button",
	    birch_button = "minecraft:birch_button",
	    jungle_button = "minecraft:jungle_button",
	    acacia_button = "minecraft:acacia_button",
	    dark_oak_button = "minecraft:dark_oak_button",
	    crimson_button = "minecraft:crimson_button",
	    warped_button = "minecraft:warped_button",
	    oak_pressure_plate = "minecraft:oak_pressure_plate",
	    spruce_pressure_plate = "minecraft:spruce_pressure_plate",
	    birch_pressure_plate = "minecraft:birch_pressure_plate",
	    jungle_pressure_plate = "minecraft:jungle_pressure_plate",
	    acacia_pressure_plate = "minecraft:acacia_pressure_plate",
	    dark_oak_pressure_plate = "minecraft:dark_oak_pressure_plate",
	    crimson_pressure_plate = "minecraft:crimson_pressure_plate",
	    warped_pressure_plate = "minecraft:warped_pressure_plate",
	    oak_door = "minecraft:oak_door",
	    spruce_door = "minecraft:spruce_door",
	    birch_door = "minecraft:birch_door",
	    jungle_door = "minecraft:jungle_door",
	    acacia_door = "minecraft:acacia_door",
	    dark_oak_door = "minecraft:dark_oak_door",
	    crimson_door = "minecraft:crimson_door",
	    warped_door = "minecraft:warped_door",
	    oak_trapdoor = "minecraft:oak_trapdoor",
	    spruce_trapdoor = "minecraft:spruce_trapdoor",
	    birch_trapdoor = "minecraft:birch_trapdoor",
	    jungle_trapdoor = "minecraft:jungle_trapdoor",
	    acacia_trapdoor = "minecraft:acacia_trapdoor",
	    dark_oak_trapdoor = "minecraft:dark_oak_trapdoor",
	    crimson_trapdoor = "minecraft:crimson_trapdoor",
	    warped_trapdoor = "minecraft:warped_trapdoor",
	    oak_sign = "minecraft:oak_sign",
	    spruce_sign = "minecraft:spruce_sign",
	    birch_sign = "minecraft:birch_sign",
	    jungle_sign = "minecraft:jungle_sign",
	    acacia_sign = "minecraft:acacia_sign",
	    bone_meal = "minecraft:bone_meal",
	    white_wool = "minecraft:white_wool",
	    orange_wool = "minecraft:orange_wool",
	    magenta_wool = "minecraft:magenta_wool",
	    light_blue_wool = "minecraft:light_blue_wool",
	    yellow_wool = "minecraft:yellow_wool",
	    lime_wool = "minecraft:lime_wool",
	    pink_wool = "minecraft:pink_wool",
	    gray_wool = "minecraft:gray_wool",
	    light_gray_wool = "minecraft:light_gray_wool",
	    cyan_wool = "minecraft:cyan_wool",
	    purple_wool = "minecraft:purple_wool",
	    blue_wool = "minecraft:blue_wool",
	    brown_wool = "minecraft:brown_wool",
	    green_wool = "minecraft:green_wool",
	    red_wool = "minecraft:red_wool",
	    black_wool = "minecraft:black_wool",
	    white_carpet = "minecraft:white_carpet",
	    orange_carpet = "minecraft:orange_carpet",
	    magenta_carpet = "minecraft:magenta_carpet",
	    light_blue_carpet = "minecraft:light_blue_carpet",
	    yellow_carpet = "minecraft:yellow_carpet",
	    lime_carpet = "minecraft:lime_carpet",
	    pink_carpet = "minecraft:pink_carpet",
	    gray_carpet = "minecraft:gray_carpet",
	    light_gray_carpet = "minecraft:light_gray_carpet",
	    cyan_carpet = "minecraft:cyan_carpet",
	    purple_carpet = "minecraft:purple_carpet",
	    blue_carpet = "minecraft:blue_carpet",
	    brown_carpet = "minecraft:brown_carpet",
	    green_carpet = "minecraft:green_carpet",
	    red_carpet = "minecraft:red_carpet",
	    black_carpet = "minecraft:black_carpet",
	    white_bed = "minecraft:white_bed",
	    orange_bed = "minecraft:orange_bed",
	    magenta_bed = "minecraft:magenta_bed",
	    light_blue_bed = "minecraft:light_blue_bed",
	    yellow_bed = "minecraft:yellow_bed",
	    lime_bed = "minecraft:lime_bed",
	    pink_bed = "minecraft:pink_bed",
	    gray_bed = "minecraft:gray_bed",
	    light_gray_bed = "minecraft:light_gray_bed",
	    cyan_bed = "minecraft:cyan_bed",
	    purple_bed = "minecraft:purple_bed",
	    blue_bed = "minecraft:blue_bed",
	    brown_bed = "minecraft:brown_bed",
	    green_bed = "minecraft:green_bed",
	    red_bed = "minecraft:red_bed",
	    black_bed = "minecraft:black_bed",
	    white_banner = "minecraft:white_banner",
	    orange_banner = "minecraft:orange_banner",
	    magenta_banner = "minecraft:magenta_banner",
	    light_blue_banner = "minecraft:light_blue_banner",
	    yellow_banner = "minecraft:yellow_banner",
	    lime_banner = "minecraft:lime_banner",
	    pink_banner = "minecraft:pink_banner",
	    gray_banner = "minecraft:gray_banner",
	    light_gray_banner = "minecraft:light_gray_banner",
	    cyan_banner = "minecraft:cyan_banner",
	    purple_banner = "minecraft:purple_banner",
	    blue_banner = "minecraft:blue_banner",
	    brown_banner = "minecraft:brown_banner",
	    green_banner = "minecraft:green_banner",
	    red_banner = "minecraft:red_banner",
	    black_banner = "minecraft:black_banner",
	    white_shulker_box = "minecraft:white_shulker_box",
	    orange_shulker_box = "minecraft:orange_shulker_box",
	    magenta_shulker_box = "minecraft:magenta_shulker_box",
	    light_blue_shulker_box = "minecraft:light_blue_shulker_box",
	    yellow_shulker_box = "minecraft:yellow_shulker_box",
	    lime_shulker_box = "minecraft:lime_shulker_box",
	    pink_shulker_box = "minecraft:pink_shulker_box",
	    gray_shulker_box = "minecraft:gray_shulker_box",
	    light_gray_shulker_box = "minecraft:light_gray_shulker_box",
	    cyan_shulker_box = "minecraft:cyan_shulker_box",
	    purple_shulker_box = "minecraft:purple_shulker_box",
	    blue_shulker_box = "minecraft:blue_shulker_box",
	    brown_shulker_box = "minecraft:brown_shulker_box",
	    green_shulker_box = "minecraft:green_shulker_box",
	    red_shulker_box = "minecraft:red_shulker_box",
	    black_shulker_box = "minecraft:black_shulker_box",
	    white_concrete = "minecraft:white_concrete",
	    orange_concrete = "minecraft:orange_concrete",
	    magenta_concrete = "minecraft:magenta_concrete",
	    light_blue_concrete = "minecraft:light_blue_concrete",
	    yellow_concrete = "minecraft:yellow_concrete",
	    lime_concrete = "minecraft:lime_concrete",
	    pink_concrete = "minecraft:pink_concrete",
	    gray_concrete = "minecraft:gray_concrete",
	    light_gray_concrete = "minecraft:light_gray_concrete",
	    cyan_concrete = "minecraft:cyan_concrete",
	    purple_concrete = "minecraft:purple_concrete",
	    blue_concrete = "minecraft:blue_concrete",
	    brown_concrete = "minecraft:brown_concrete",
	    green_concrete = "minecraft:green_concrete",
	    red_concrete = "minecraft:red_concrete",
	    black_concrete = "minecraft:black_concrete",
	    white_concrete_powder = "minecraft:white_concrete_powder",
	    orange_concrete_powder = "minecraft:orange_concrete_powder",
	    magenta_concrete_powder = "minecraft:magenta_concrete_powder",
	    light_blue_concrete_powder = "minecraft:light_blue_concrete_powder",
	    yellow_concrete_powder = "minecraft:yellow_concrete_powder",
	    lime_concrete_powder = "minecraft:lime_concrete_powder",
	    pink_concrete_powder = "minecraft:pink_concrete_powder",
	    gray_concrete_powder = "minecraft:gray_concrete_powder",
	    light_gray_concrete_powder = "minecraft:light_gray_concrete_powder",
	    cyan_concrete_powder = "minecraft:cyan_concrete_powder",
	    purple_concrete_powder = "minecraft:purple_concrete_powder",
	    blue_concrete_powder = "minecraft:blue_concrete_powder",
	    brown_concrete_powder = "minecraft:brown_concrete_powder",
	    green_concrete_powder = "minecraft:green_concrete_powder",
	    red_concrete_powder = "minecraft:red_concrete_powder",
	    black_concrete_powder = "minecraft:black_concrete_powder",
	    white_glazed_terracotta = "minecraft:white_glazed_terracotta",
	    orange_glazed_terracotta = "minecraft:orange_glazed_terracotta",
	    magenta_glazed_terracotta = "minecraft:magenta_glazed_terracotta",
	    light_blue_glazed_terracotta = "minecraft:light_blue_glazed_terracotta",
	    yellow_glazed_terracotta = "minecraft:yellow_glazed_terracotta",
	    lime_glazed_terracotta = "minecraft:lime_glazed_terracotta",
	    pink_glazed_terracotta = "minecraft:pink_glazed_terracotta",
	    gray_glazed_terracotta = "minecraft:gray_glazed_terracotta",
	    light_gray_glazed_terracotta = "minecraft:light_gray_glazed_terracotta",
	    cyan_glazed_terracotta = "minecraft:cyan_glazed_terracotta",
	    purple_glazed_terracotta = "minecraft:purple_glazed_terracotta",
	    blue_glazed_terracotta = "minecraft:blue_glazed_terracotta",
	    brown_glazed_terracotta = "minecraft:brown_glazed_terracotta",
	    green_glazed_terracotta = "minecraft:green_glazed_terracotta",
	    red_glazed_terracotta = "minecraft:red_glazed_terracotta",
	    black_glazed_terracotta = "minecraft:black_glazed_terracotta",
	    white_stained_glass = "minecraft:white_stained_glass",
	    orange_stained_glass = "minecraft:orange_stained_glass",
	    magenta_stained_glass = "minecraft:magenta_stained_glass",
	    light_blue_stained_glass = "minecraft:light_blue_stained_glass",
	    yellow_stained_glass = "minecraft:yellow_stained_glass",
	    lime_stained_glass = "minecraft:lime_stained_glass",
	    pink_stained_glass = "minecraft:pink_stained_glass",
	    gray_stained_glass = "minecraft:gray_stained_glass",
	    light_gray_stained_glass = "minecraft:light_gray_stained_glass",
	    cyan_stained_glass = "minecraft:cyan_stained_glass",
	    purple_stained_glass = "minecraft:purple_stained_glass",
	    blue_stained_glass = "minecraft:blue_stained_glass",
	    brown_stained_glass = "minecraft:brown_stained_glass",
	    green_stained_glass = "minecraft:green_stained_glass",
	    red_stained_glass = "minecraft:red_stained_glass",
	    black_stained_glass = "minecraft:black_stained_glass",
	    white_stained_glass_pane = "minecraft:white_stained_glass_pane",
	    orange_stained_glass_pane = "minecraft:orange_stained_glass_pane",
	    magenta_stained_glass_pane = "minecraft:magenta_stained_glass_pane",
	    light_blue_stained_glass_pane = "minecraft:light_blue_stained_glass_pane",
	    yellow_stained_glass_pane = "minecraft:yellow_stained_glass_pane",
	    lime_stained_glass_pane = "minecraft:lime_stained_glass_pane",
	    pink_stained_glass_pane = "minecraft:pink_stained_glass_pane",
	    gray_stained_glass_pane = "minecraft:gray_stained_glass_pane",
	    light_gray_stained_glass_pane = "minecraft:light_gray_stained_glass_pane",
	    cyan_stained_glass_pane = "minecraft:cyan_stained_glass_pane",
	    purple_stained_glass_pane = "minecraft:purple_stained_glass_pane",
	    blue_stained_glass_pane = "minecraft:blue_stained_glass_pane",
	    brown_stained_glass_pane = "minecraft:brown_stained_glass_pane",
	    green_stained_glass_pane = "minecraft:green_stained_glass_pane",
	    red_stained_glass_pane = "minecraft:red_stained_glass_pane",
	    black_stained_glass_pane = "minecraft:black_stained_glass_pane",
	    white_terracotta = "minecraft:white_terracotta",
	    orange_terracotta = "minecraft:orange_terracotta",
	    magenta_terracotta = "minecraft:magenta_terracotta",
	    light_blue_terracotta = "minecraft:light_blue_terracotta",
	    yellow_terracotta = "minecraft:yellow_terracotta",
	    lime_terracotta = "minecraft:lime_terracotta",
	    pink_terracotta = "minecraft:pink_terracotta",
	    gray_terracotta = "minecraft:gray_terracotta",
	    light_gray_terracotta = "minecraft:light_gray_terracotta",
	    cyan_terracotta = "minecraft:cyan_terracotta",
	    purple_terracotta = "minecraft:purple_terracotta",
	    blue_terracotta = "minecraft:blue_terracotta",
	    brown_terracotta = "minecraft:brown_terracotta",
	    green_terracotta = "minecraft:green_terracotta",
	    red_terracotta = "minecraft:red_terracotta",
	    black_terracotta = "minecraft:black_terracotta",
	    quartz_block = "minecraft:quartz_block",
	    obsidian = "minecraft:obsidian",
	    glowstone = "minecraft:glowstone",
	    netherrack = "minecraft:netherrack",
	    soul_sand = "minecraft:soul_sand",
	    sand = "minecraft:sand",
	    gravel = "minecraft:gravel",
	    dirt = "minecraft:dirt",
	    grass_block = "minecraft:grass_block",
	    stone_bricks = "minecraft:stone_bricks",
	    stone_brick_stairs = "minecraft:stone_brick_stairs",
	    stone_brick_slab = "minecraft:stone_brick_slab",
	    stone_brick_wall = "minecraft:stone_brick_wall",
	    mossy_stone_bricks = "minecraft:mossy_stone_bricks",
	    cracked_stone_bricks = "minecraft:cracked_stone_bricks",
	    chiseled_stone_bricks = "minecraft:chiseled_stone_bricks",
	    cobblestone = "minecraft:cobblestone",
	    mossy_cobblestone = "minecraft:mossy_cobblestone",
	    chiseled_sandstone = "minecraft:chiseled_sandstone",
	    cut_sandstone = "minecraft:cut_sandstone",
	    smooth_sandstone = "minecraft:smooth_sandstone",
	    sandstone = "minecraft:sandstone",
	    red_sand = "minecraft:red_sand",
	    red_sandstone = "minecraft:red_sandstone",
	    smooth_red_sandstone = "minecraft:smooth_red_sandstone",
	    cut_red_sandstone = "minecraft:cut_red_sandstone",
	    chiseled_red_sandstone = "minecraft:chiseled_red_sandstone",
	    red_sandstone_stairs = "minecraft:red_sandstone_stairs",
	    red_sandstone_slab = "minecraft:red_sandstone_slab",
	    red_sandstone_wall = "minecraft:red_sandstone_wall",
	    smooth_red_sandstone_slab = "minecraft:smooth_red_sandstone_slab",
	    smooth_red_sandstone_stairs = "minecraft:smooth_red_sandstone_stairs",
	    smooth_red_sandstone_wall = "minecraft:smooth_red_sandstone_wall",
	    cut_red_sandstone_slab = "minecraft:cut_red_sandstone_slab",
	    cut_red_sandstone_stairs = "minecraft:cut_red_sandstone_stairs",
	    cut_red_sandstone_wall = "minecraft:cut_red_sandstone_wall",
	    chiseled_red_sandstone_slab = "minecraft:chiseled_red_sandstone_slab",
	    chiseled_red_sandstone_stairs = "minecraft:chiseled_red_sandstone_stairs",
	    chiseled_red_sandstone_wall = "minecraft:chiseled_red_sandstone_wall",
	    rotten_flesh = "minecraft:rotten_flesh",
	    string = "minecraft:string",
	    spider_eye = "minecraft:spider_eye",
	    fermented_spider_eye = "minecraft:fermented_spider_eye",
	    blaze_powder = "minecraft:blaze_powder",
	    magma_cream = "minecraft:magma_cream",
	    ghast_tear = "minecraft:ghast_tear",
	    ender_pearl = "minecraft:ender_pearl",
	    ender_eye = "minecraft:ender_eye",
	    nether_star = "minecraft:nether_star",
	    nether_wart = "minecraft:nether_wart",
	    nether_brick = "minecraft:nether_brick",
	    nether_brick_fence = "minecraft:nether_brick_fence",
	    nether_brick_stairs = "minecraft:nether_brick_stairs",
	    nether_brick_slab = "minecraft:nether_brick_slab",
	    nether_brick_wall = "minecraft:nether_brick_wall",
	    nether_brick_block = "minecraft:nether_brick_block",
	    nether_bricks = "minecraft:nether_bricks",
	    nether_quartz = "minecraft:nether_quartz",
	    nether_quartz_ore = "minecraft:nether_quartz_ore",
	    quartz_pillar = "minecraft:quartz_pillar",
	    quartz_bricks = "minecraft:quartz_bricks",
	    quartz_wall = "minecraft:quartz_wall",
	    quartz_ore = "minecraft:quartz_ore",
	    quartz = "minecraft:quartz",
	    quartz_slab = "minecraft:quartz_slab",
	    quartz_stairs = "minecraft:quartz_stairs",
	    granite = "minecraft:granite",
	    polished_granite = "minecraft:polished_granite",
	    granite_slab = "minecraft:granite_slab",
	    granite_stairs = "minecraft:granite_stairs",
	    granite_wall = "minecraft:granite_wall",
	    diorite = "minecraft:diorite",
	    polished_diorite = "minecraft:polished_diorite",
	    diorite_slab = "minecraft:diorite_slab",
	    diorite_stairs = "minecraft:diorite_stairs",
	    diorite_wall = "minecraft:diorite_wall",
	    andesite = "minecraft:andesite",
	    polished_andesite = "minecraft:polished_andesite",
	    andesite_slab = "minecraft:andesite_slab",
	    andesite_stairs = "minecraft:andesite_stairs",
	    andesite_wall = "minecraft:andesite_wall",
	    prismarine = "minecraft:prismarine",
	    prismarine_bricks = "minecraft:prismarine_bricks",
	    dark_prismarine = "minecraft:dark_prismarine",
	    prismarine_slab = "minecraft:prismarine_slab",
	    prismarine_stairs = "minecraft:prismarine_stairs",
	    prismarine_wall = "minecraft:prismarine_wall",
	    prismarine_brick_slab = "minecraft:prismarine_brick_slab",
	    prismarine_brick_stairs = "minecraft:prismarine_brick_stairs",
	    prismarine_brick_wall = "minecraft:prismarine_brick_wall",
	    dark_prismarine_slab = "minecraft:dark_prismarine_slab",
	    dark_prismarine_stairs = "minecraft:dark_prismarine_stairs",
	    dark_prismarine_wall = "minecraft:dark_prismarine_wall",
	    sea_lantern = "minecraft:sea_lantern",
	    end_stone = "minecraft:end_stone",
	    end_stone_bricks = "minecraft:end_stone_bricks",
	    end_stone_brick_slab = "minecraft:end_stone_brick_slab",
	    end_stone_brick_stairs = "minecraft:end_stone_brick_stairs",
	    end_stone_brick_wall = "minecraft:end_stone_brick_wall",
	    purpur_block = "minecraft:purpur_block",
	    purpur_pillar = "minecraft:purpur_pillar",
	    purpur_slab = "minecraft:purpur_slab",
	    purpur_stairs = "minecraft:purpur_stairs",
	    purpur_purpur_block = "minecraft:purpur_purpur_block",
	    purpur_purpur_pillar = "minecraft:purpur_purpur_pillar",
	    purpur_purpur_slab = "minecraft:purpur_purpur_slab",
	    purpur_purpur_stairs = "minecraft:purpur_purpur_stairs",
	    end_bricks = "minecraft:end_bricks",
	    end_rod = "minecraft:end_rod",
	    blackstone = "minecraft:blackstone",
	    polished_blackstone = "minecraft:polished_blackstone",
	    polished_blackstone_slab = "minecraft:polished_blackstone_slab",
	    polished_blackstone_stairs = "minecraft:polished_blackstone_stairs",
	    polished_blackstone_wall = "minecraft:polished_blackstone_wall",
	    polished_blackstone_brick_slab = "minecraft:polished_blackstone_brick_slab",
	    polished_blackstone_brick_stairs = "minecraft:polished_blackstone_brick_stairs",
	    polished_blackstone_brick_wall = "minecraft:polished_blackstone_brick_wall",
	    blackstone_slab = "minecraft:blackstone_slab",
	    blackstone_stairs = "minecraft:blackstone_stairs",
	    blackstone_wall = "minecraft:blackstone_wall",
	    blackstone_bricks = "minecraft:blackstone_bricks",
	    polished_blackstone_bricks = "minecraft:polished_blackstone_bricks",
	    polished_blackstone_brick = "minecraft:polished_blackstone_brick",
	    blackstone_brick_slab = "minecraft:blackstone_brick_slab",
	    blackstone_brick_stairs = "minecraft:blackstone_brick_stairs",
	    blackstone_brick_wall = "minecraft:blackstone_brick_wall",
	    water = "minecraft:water",
	    lava = "minecraft:lava",
	    computercraft_cable = "computercraft:cable",
	    computercraft_computer = "computercraft:computer",
	    computercraft_computer_advanced = "computercraft:computer_advanced",
	    computercraft_computer_command = "computercraft:computer_command",
	    computercraft_wireless_modem_advanced = "computercraft:wireless_modem_advanced",
	    computercraft_wired_modem_full = "computercraft:wired_modem_full",
	    computercraft_wired_modem = "computercraft:wired_modem",
	    computercraft_turtle_advanced = "computercraft:turtle_advanced",
	    computercraft_turtle_normal = "computercraft:turtle_normal",
	    irons_spellbooks_arcane_debris = "irons_spellbooks:arcane_debris",
	}
	return Blocks
end
local utils_blocks_Blocks = MODULE_utils_blocks_Blocks()


function MODULE_utils_movement_Rotations()
	Rotations = {}
	Rotations.NONE = "None"
	Rotations.UP = "Up"
	Rotations.DOWN = "Down"
	Rotations.LEFT = "Left"
	Rotations.RIGHT = "Right"
	function Rotations.opposite(direction)
	    if direction == Rotations.UP then
	        return Rotations.DOWN
	    elseif direction == Rotations.DOWN then
	        return Rotations.UP
	    elseif direction == Rotations.LEFT then
	        return Rotations.RIGHT
	    elseif direction == Rotations.RIGHT then
	        return Rotations.LEFT
	    end
	end
	return Rotations
end
local utils_movement_Rotations = MODULE_utils_movement_Rotations()


function MODULE_utils_movement_Direction()
	local Rotations = utils_movement_Rotations
	local Direction = {}
	Direction.__index = Direction
	Direction.NORTH = "North"  -- -z
	Direction.EAST = "East"  -- +x
	Direction.SOUTH = "South"  -- +z
	Direction.WEST = "West"  -- -x
	Direction.UP = "Up"  -- +y
	Direction.DOWN = "Down"  -- -y
	Direction.DIRECTIONS = {
	    Direction.NORTH,
	    Direction.EAST,
	    Direction.SOUTH,
	    Direction.WEST,
	    Direction.UP,
	    Direction.DOWN,
	}
	Direction.HORIZONTAL_DIRECTIONS = {
	    Direction.NORTH,
	    Direction.EAST,
	    Direction.SOUTH,
	    Direction.WEST,
	}
	function Direction.opposite(direction)
	    if direction == Direction.NORTH then
	        return Direction.SOUTH
	    elseif direction == Direction.SOUTH then
	        return Direction.NORTH
	    elseif direction == Direction.EAST then
	        return Direction.WEST
	    elseif direction == Direction.WEST then
	        return Direction.EAST
	    elseif direction == Direction.UP then
	        return Direction.DOWN
	    elseif direction == Direction.DOWN then
	        return Direction.UP
	    end
	end
	function Direction.nextLeft(direction)
	    if direction == Direction.NORTH then
	        return Direction.WEST
	    elseif direction == Direction.WEST then
	        return Direction.SOUTH
	    elseif direction == Direction.SOUTH then
	        return Direction.EAST
	    elseif direction == Direction.EAST then
	        return Direction.NORTH
	    end
	end
	function Direction.nextRight(direction)
	    if direction == Direction.NORTH then
	        return Direction.EAST
	    elseif direction == Direction.EAST then
	        return Direction.SOUTH
	    elseif direction == Direction.SOUTH then
	        return Direction.WEST
	    elseif direction == Direction.WEST then
	        return Direction.NORTH
	    end
	end
	function Direction.getBestDirectionToTurn(currentDirection, targetDirection)
	    if currentDirection == targetDirection then
	        return Rotations.NONE
	    elseif Direction.nextLeft(currentDirection) == targetDirection then
	        return Rotations.LEFT
	    elseif Direction.nextRight(currentDirection) == targetDirection then
	        return Rotations.RIGHT
	    else
	        return Rotations.LEFT  -- Both are acceptable, pick a default
	    end
	end
	return Direction
end
local utils_movement_Direction = MODULE_utils_movement_Direction()


function MODULE_utils_math_Vector3()
	local Direction = utils_movement_Direction
	local Terminal = utils_terminal_Terminal
	local Vector3 = {}
	Vector3.__index = Vector3
	function Vector3.new(x, y, z)
	    if type(x) == "table" then
	        x, y, z = x.x, x.y, x.z
	    end
	    return setmetatable({x = x or 0, y = y or 0, z = z or 0}, Vector3)
	end
	function Vector3.randint(min, max)
	    return Vector3.new(math.random(min.x, max.x), math.random(min.y, max.y), math.random(min.z, max.z))
	end
	function Vector3.radomFloat(min, max)
	    return Vector3.new(math.random() * (max.x - min.x) + min.x, math.random() * (max.y - min.y) + min.y, math.random() * (max.z - min.z) + min.z)
	end
	function Vector3.fromTerminal(prompt)
	    prompt = prompt or "Enter a Vector3: "
	    local table = Terminal.readTable(prompt, Vector3.new(0, 0, 0):toTable())
	    return Vector3.new(table.x, table.y, table.z)
	end
	function Vector3.fromTable(tbl)
	    return Vector3.new(tbl.x, tbl.y, tbl.z)
	end
	function Vector3:toTable()
	    return {x = self.x, y = self.y, z = self.z}
	end
	function Vector3:equals(other)
	    return self.x == other.x and self.y == other.y and self.z == other.z
	end
	function Vector3:copy()
	    return Vector3.new(self.x, self.y, self.z)
	end
	function Vector3:add(other)
	    return Vector3.new(self.x + other.x, self.y + other.y, self.z + other.z)
	end
	function Vector3:addInDirection(direction, distance)
	    distance = distance or 1
	    local result = self:copy()
	    if direction == Direction.NORTH then
	        result.z = result.z - distance
	    elseif direction == Direction.SOUTH then
	        result.z = result.z + distance
	    elseif direction == Direction.EAST then
	        result.x = result.x + distance
	    elseif direction == Direction.WEST then
	        result.x = result.x - distance
	    elseif direction == Direction.UP then
	        result.y = result.y + distance
	    elseif direction == Direction.DOWN then
	        result.y = result.y - distance
	    end
	    return result
	end
	function Vector3:addInOppositeDirection(direction, distance)
	    return self:addInDirection(Direction.opposite(direction), distance)
	end
	function Vector3:sub(other)
	    return Vector3.new(self.x - other.x, self.y - other.y, self.z - other.z)
	end
	function Vector3:mul(scalar)
	    return Vector3.new(self.x * scalar, self.y * scalar, self.z * scalar)
	end
	function Vector3:dot(other)
	    return self.x * other.x + self.y * other.y + self.z * other.z
	end
	function Vector3:cross(other)
	    return Vector3.new(
	        self.y * other.z - self.z * other.y,
	        self.z * other.x - self.x * other.z,
	        self.x * other.y - self.y * other.x
	    )
	end
	function Vector3:magnitude()
	    return math.sqrt(self.x^2 + self.y^2 + self.z^2)
	end
	function Vector3:normalize()
	    local mag = self:magnitude()
	    if mag > 0 then
	        return Vector3.new(self.x / mag, self.y / mag, self.z / mag)
	    else
	        return Vector3.new(0, 0, 0)
	    end
	end
	function Vector3:distanceTo(other)
	    return (self:sub(other)):magnitude()
	end
	function Vector3:serialize()
	    return string.format("%.6f,%.6f,%.6f", self.x, self.y, self.z)
	end
	function Vector3.deserialize(str)
	    local x, y, z = str:match("([^,]+),([^,]+),([^,]+)")
	    return Vector3.new(tonumber(x), tonumber(y), tonumber(z))
	end
	function Vector3:directionTo(other)
	    local diff = other:sub(self)
	    if diff:equals(Vector3.new(0, 0, 0)) then
	        return nil
	    end
	    if diff.x > 0 then
	        return Direction.EAST
	    elseif diff.x < 0 then
	        return Direction.WEST
	    elseif diff.z > 0 then
	        return Direction.SOUTH
	    elseif diff.z < 0 then
	        return Direction.NORTH
	    elseif diff.y > 0 then
	        return Direction.UP
	    elseif diff.y < 0 then
	        return Direction.DOWN
	    end
	end
	function Vector3:horizontalDirectionTo(other)
	    local diff = other:sub(self)
	    if diff:equals(Vector3.new(0, 0, 0)) then
	        return nil
	    end
	    if math.abs(diff.x) > math.abs(diff.z) then
	        if diff.x > 0 then
	            return Direction.EAST
	        else
	            return Direction.WEST
	        end
	    else
	        if diff.z > 0 then
	            return Direction.SOUTH
	        else
	            return Direction.NORTH
	        end
	    end
	end
	function Vector3:verticalDirectionTo(other)
	    local diff = other:sub(self)
	    if diff:equals(Vector3.new(0, 0, 0)) then
	        return nil
	    end
	    if diff.y > 0 then
	        return Direction.UP
	    elseif diff.y < 0 then
	        return Direction.DOWN
	    end
	end
	function Vector3:__tostring()
	    return string.format("Vector3(%.2f, %.2f, %.2f)", self.x, self.y, self.z)
	end
	return Vector3
end
local utils_math_Vector3 = MODULE_utils_math_Vector3()


function MODULE_utils_blocks_Block()
	local Blocks = utils_blocks_Blocks
	local Table = utils_data_Table
	local Vector3= utils_math_Vector3
	local Text = utils_text_Text
	local blockLookupTable = {}
	for blocksKey, blockName in pairs(Blocks) do
	    blockLookupTable[blockName] = blocksKey
	end
	local protectedBlocks = {
	    Blocks.barrel,
	    Blocks.chest,
	    Blocks.enderChest,
	    Blocks.shulkerBox,
	    Blocks.trappedChest,
	    Blocks.hopper,
	    Blocks.dispenser,
	    Blocks.dropper,
	    Blocks.furnace,
	    Blocks.blastFurnace,
	    Blocks.smoker,
	    Blocks.brewingStand,
	    Blocks.enchantingTable,
	    Blocks.craftingTable,
	    Blocks.anvil,
	    Blocks.grindstone,
	    Blocks.smithingTable,
	    Blocks.loom,
	    Blocks.cartographyTable,
	    Blocks.stonecutter,
	    Blocks.beehive,
	    Blocks.beeNest,
	    Blocks.computercraft_cable,
	    Blocks.computercraft_computer,
	    Blocks.computercraft_computer_advanced,
	    Blocks.computercraft_computer_command,
	    Blocks.computercraft_wireless_modem_advanced,
	    Blocks.computercraft_wired_modem_full,
	    Blocks.computercraft_wired_modem,
	    Blocks.computercraft_turtle,
	}
	local liquidBlocks = {
	    Blocks.water,
	    Blocks.lava,
	}
	local treeBlocks = {
	    Blocks.acacia_leaves,
	    Blocks.acacia_log,
	    Blocks.spruce_leaves,
	    Blocks.spruce_log,
	    Blocks.birch_leaves,
	    Blocks.birch_log,
	    Blocks.dark_oak_leaves,
	    Blocks.dark_oak_log,
	    Blocks.jungle_leaves,
	    Blocks.jungle_log,
	    Blocks.oak_leaves,
	    Blocks.oak_log,
	    Blocks.mangrove_leaves,
	    Blocks.mangrove_log,
	}
	local groups = {
	    wood = {Blocks.oak_wood, Blocks.spruce_wood, Blocks.birch_wood, Blocks.jungle_wood, Blocks.acacia_wood, Blocks.dark_oak_wood, Blocks.mangrove_wood},
	    log = {Blocks.oak_log, Blocks.spruce_log, Blocks.birch_log, Blocks.jungle_log, Blocks.acacia_log, Blocks.dark_oak_log, Blocks.mangrove_log},
	    leaves = {Blocks.oak_leaves, Blocks.spruce_leaves, Blocks.birch_leaves, Blocks.jungle_leaves, Blocks.acacia_leaves, Blocks.dark_oak_leaves, Blocks.mangrove_leaves},
	    sapling = {Blocks.oak_sapling, Blocks.spruce_sapling, Blocks.birch_sapling, Blocks.jungle_sapling, Blocks.acacia_sapling, Blocks.dark_oak_sapling, Blocks.mangrove_sapling},
	    planks = {Blocks.oak_planks, Blocks.spruce_planks, Blocks.birch_planks, Blocks.jungle_planks, Blocks.acacia_planks, Blocks.dark_oak_planks, Blocks.mangrove_planks},
	    slab = {Blocks.oak_slab, Blocks.spruce_slab, Blocks.birch_slab, Blocks.jungle_slab, Blocks.acacia_slab, Blocks.dark_oak_slab, Blocks.mangrove_slab},
	    stairs = {Blocks.oak_stairs, Blocks.spruce_stairs, Blocks.birch_stairs, Blocks.jungle_stairs, Blocks.acacia_stairs, Blocks.dark_oak_stairs, Blocks.mangrove_stairs},
	    fence = {Blocks.oak_fence, Blocks.spruce_fence, Blocks.birch_fence, Blocks.jungle_fence, Blocks.acacia_fence, Blocks.dark_oak_fence, Blocks.mangrove_fence},
	    fenceGate = {Blocks.oak_fence_gate, Blocks.spruce_fence_gate, Blocks.birch_fence_gate, Blocks.jungle_fence_gate, Blocks.acacia_fence_gate, Blocks.dark_oak_fence_gate, Blocks.mangrove_fence_gate},
	    door = {Blocks.oak_door, Blocks.spruce_door, Blocks.birch_door, Blocks.jungle_door, Blocks.acacia_door, Blocks.dark_oak_door, Blocks.mangrove_door},
	    trapdoor = {Blocks.oak_trapdoor, Blocks.spruce_trapdoor, Blocks.birch_trapdoor, Blocks.jungle_trapdoor, Blocks.acacia_trapdoor, Blocks.dark_oak_trapdoor, Blocks.mangrove_trapdoor},
	    button = {Blocks.oak_button, Blocks.spruce_button, Blocks.birch_button, Blocks.jungle_button, Blocks.acacia_button, Blocks.dark_oak_button, Blocks.mangrove_button},
	    pressurePlate = {Blocks.oak_pressure_plate, Blocks.spruce_pressure_plate, Blocks.birch_pressure_plate, Blocks.jungle_pressure_plate, Blocks.acacia_pressure_plate, Blocks.dark_oak_pressure_plate, Blocks.mangrove_pressure_plate},
	    sign = {Blocks.oak_sign, Blocks.spruce_sign, Blocks.birch_sign, Blocks.jungle_sign, Blocks.acacia_sign, Blocks.dark_oak_sign, Blocks.mangrove_sign},
	    boat = {Blocks.oak_boat, Blocks.spruce_boat, Blocks.birch_boat, Blocks.jungle_boat, Blocks.acacia_boat, Blocks.dark_oak_boat, Blocks.mangrove_boat},
	}
	local Block = {}
	Block.__index = Block
	function Block.new(name, position, state, tags)
	    if Block.exists(name) == false then
	        print("Block with name " .. name .. " does not exist")
	    end
	    return setmetatable({
	        name = name,
	        position = position or Vector3.new(0, 0, 0),
	        state = state or {},
	        tags = tags or {},
	    }, Block)
	end
	function Block.isAllowedToBreak(name)
	    for _, protectedBlockName in ipairs(protectedBlocks) do
	        if name == protectedBlockName then
	            return false
	        end
	    end
	    return true
	end
	function Block.isLiquid(name)
	    for _, liquidBlockName in ipairs(liquidBlocks) do
	        if name == liquidBlockName then
	            return true
	        end
	    end
	    return false
	end
	function Block.isTree(name)
	    for _, treeBlockName in ipairs(treeBlocks) do
	        if name == treeBlockName then
	            return true
	        end
	    end
	    return false
	end
	function Block.isLog(name)
	    return name == Blocks.acacia_log
	        or name == Blocks.spruce_log
	        or name == Blocks.birch_log
	        or name == Blocks.dark_oak_log
	        or name == Blocks.jungle_log
	        or name == Blocks.oak_log
	        or name == Blocks.mangrove_log
	end
	function Block.isSapling(name)
	    return name == Blocks.acacia_sapling
	        or name == Blocks.spruce_sapling
	        or name == Blocks.birch_sapling
	        or name == Blocks.dark_oak_sapling
	        or name == Blocks.jungle_sapling
	        or name == Blocks.oak_sapling
	        or name == Blocks.mangrove_sapling
	end
	function Block.isLeaf(name)
	    return name == Blocks.acacia_leaves
	        or name == Blocks.spruce_leaves
	        or name == Blocks.birch_leaves
	        or name == Blocks.dark_oak_leaves
	        or name == Blocks.jungle_leaves
	        or name == Blocks.oak_leaves
	        or name == Blocks.mangrove_leaves
	end
	function Block.isFuel(name)
	    return name == Blocks.charcoal
	    or name == Blocks.charcoal_block
	    or name == Blocks.coal
	    or name == Blocks.coal_block
	    or name == Blocks.dried_kelp_block
	    or name == Blocks.lava_bucket
	    or name == Blocks.blaze_rod
	    or name == Blocks.spruce_log
	    or name == Blocks.spruce_planks
	    or name == Blocks.stick
	end
	function Block.exists(name)
	    return blockLookupTable[name] ~= nil
	end
	function Block:__tostring()
	    return string.format(
	        "Block(%s, %s)",
	        self.name,
	        self.position
	    )
	end
	function Block.getClosestMatch(name, customBlocksList)
	    customBlocksList = customBlocksList or Blocks
	    local closestMatch, score = Text.getClosestMatch(name, customBlocksList)
	    local closestMatchGroup, groupScore = Text.getClosestMatchingGroup(name, groups)
	    if groupScore <= score then
	        closestMatchGroup = Table.intersection(customBlocksList, closestMatchGroup)
	        if closestMatchGroup == nil or #closestMatchGroup == 0 then
	            return {name = name, closestMatch = closestMatch, closestMatchGroup = closestMatchGroup, score = groupScore}
	        else
	            return {name = name, closestMatch = closestMatchGroup[1], closestMatchGroup = closestMatchGroup, score = groupScore}
	        end
	    else
	        return {name = name, closestMatch = closestMatch, score = score}
	    end
	end
	return Block
end
local utils_blocks_Block = MODULE_utils_blocks_Block()


function MODULE_utils_config_Config()
	local Vector3 = utils_math_Vector3
	local file = utils_other_file
	local Direction = utils_movement_Direction
	local Job       = jobs_Job
	local Blocks = utils_blocks_Blocks
	local Config = {}
	Config.__index = Config
	function Config.new()
	    local self = setmetatable({
	        turtleName = "MyTurtle",
	        job = Job.SETUP,
	        homePosition = Vector3.new({x = 0, y = 0, z = 0}),
	        homeDirection = Direction.NORTH,
	        fuelMinimum = 64,
	        fuelTarget = 256,
	        fuelItem = Blocks.charcoal,
	    }, Config)
	    return self
	end
	function Config.fromTable(table)
	    local self = Config.new()
	    self.turtleName = table.turtleName or self.turtleName
	    self.task = table.task or self.tasks
	    self.homePosition = Vector3.fromTable(table.homePosition) or self.homePosition
	    self.homeDirection = table.homeDirection or self.homeDirection
	    self.fuelMinimum = table.fuelMinimum or self.fuelMinimum
	    self.fuelTarget = table.fuelTarget or self.fuelTarget
	    self.fuelItem = table.fuelItem or self.fuelItem
	    return self
	end
	function Config:toTable()
	    return {
	        turtleName = self.turtleName,
	        task = self.task,
	        homePosition = self.homePosition:toTable(),
	        homeDirection = self.homeDirection,
	        fuelMinimum = self.fuelMinimum,
	        fuelTarget = self.fuelTarget,
	        fuelItem = self.fuelItem,
	    }
	end
	function Config:serializeJson()
	    local text = textutils.serializeJSON(self:toTable())
	    return text
	end
	function Config.deserializeJson(json)
	    local configAttributes = textutils.unserializeJSON(json)
	    local config = Config.fromTable(configAttributes)
	    return config
	end
	function Config:save()
	   file.writeText("config.json", self:serializeJson())
	end
	function Config.load()
	    local config = nil
	    local content = file.readText("config.json")
	    if content == nil then
	        config = Config.new()
	    else
	        config = Config.deserializeJson(content)
	    end
	    config:save()  -- Save any default values that were missing
	    return config
	end
	return Config
end
local utils_config_Config = MODULE_utils_config_Config()


function MODULE_turtle_Inventory()
	local Blocks = utils_blocks_Blocks
	local Block = utils_blocks_Block
	local Side = turtle_Side
	local Inventory = {}
	function Inventory.isFull()
	    return Inventory.getEmptySlot() == nil
	end
	function Inventory.isEmpty()
	    return Inventory.isFull() == false
	end
	function Inventory.getEmptySlot()
	    for i = 1, 16 do
	        if turtle.getItemCount(i) == 0 then
	            return i
	        end
	    end
	    return nil
	end
	function Inventory.getSlotWithItem(name)
	    for i = 1, 16 do
	        local item = turtle.getItemDetail(i)
	        if item ~= nil and item.name == name then
	            return i
	        end
	    end
	    return nil
	end
	function Inventory.getSlotWithSapling()
	    for i = 1, 16 do
	        local item = turtle.getItemDetail(i)
	        if item ~= nil and Block.isSapling(item.name) then
	            return i
	        end
	    end
	    return nil
	end
	function Inventory.getSlotWithFuel()
	    for i = 1, 16 do
	        local item = turtle.getItemDetail(i)
	        if item ~= nil and Block.isFuel(item.name) then
	            return i
	        end
	    end
	    return nil
	end
	function Inventory.getItemCount(name)
	    local count = 0
	    for i = 1, 16 do
	        local item = turtle.getItemDetail(i)
	        if item ~= nil and item.name == name then
	            count = count + item.count
	        end
	    end
	    return count
	end
	function Inventory.countSaplings()
	    return Inventory.getItemCount(Blocks.acacia_sapling)
	        + Inventory.getItemCount(Blocks.birch_sapling)
	        + Inventory.getItemCount(Blocks.dark_oak_sapling)
	        + Inventory.getItemCount(Blocks.jungle_sapling)
	        + Inventory.getItemCount(Blocks.oak_sapling)
	        + Inventory.getItemCount(Blocks.spruce_sapling)
	        + Inventory.getItemCount(Blocks.mangrove_sapling)
	end
	function Inventory.findContainerSide()
	    local p = peripheral.getType(Side.FRONT)
	    if p == Blocks.barrel or p == Blocks.chest then return Side.FRONT end
	    p = peripheral.getType(Side.TOP)
	    if p == Blocks.barrel or p == Blocks.chest then return Side.TOP end
	    p = peripheral.getType(Side.BOTTOM)
	    if p == Blocks.barrel or p == Blocks.chest then return Side.BOTTOM end
	    turtle.turnLeft()
	    p = peripheral.getType(Side.FRONT)
	    if p == Blocks.barrel or p == Blocks.chest then
	        turtle.turnRight()
	        return Side.LEFT
	    end
	    turtle.turnLeft()
	    p = peripheral.getType(Side.FRONT)
	    if p == Blocks.barrel or p == Blocks.chest then
	        turtle.turnRight()
	        turtle.turnRight()
	        return Side.BACK
	    end
	    turtle.turnLeft()
	    p = peripheral.getType(Side.FRONT)
	    if p == Blocks.barrel or p == Blocks.chest then
	        turtle.turnLeft()
	        return Side.RIGHT
	    end
	end
	function Inventory.pullFromContainer()
	    local side = Inventory.findContainerSide()
	    if side == nil then
	        return false
	    end
	    local suckFunction = turtle.suck
	    if side == Side.up then
	        suckFunction = turtle.suckUp
	    elseif side == Side.down then
	        suckFunction = turtle.suckDown
	    end
	    while suckFunction() do end
	    return
	end
	function Inventory.dumpIntoContainer()
	    local side = Inventory.findContainerSide()
	    if side == nil then
	        return false
	    end
	    local dropFunction = turtle.drop
	    if side == Side.up then
	        dropFunction = turtle.dropUp
	    elseif side == Side.down then
	        dropFunction = turtle.dropDown
	    end
	    for i = 1, 16 do
	        turtle.select(i)
	        dropFunction()
	    end
	end
	function Inventory.getEmptySlots()
	    local emptySlots = 0
	    for i = 1, 16 do
	        if turtle.getItemCount(i) == 0 then
	            emptySlots = emptySlots + 1
	        end
	    end
	    return emptySlots
	end
	function Inventory.getSize()
	    return 16
	end
	return Inventory
end
local turtle_Inventory = MODULE_turtle_Inventory()


function MODULE_utils_peripherals_Compass()
	local Compass = {}
	function Compass.new()
	    local self = setmetatable({}, Compass)
	    self.internal = peripheral.find("compass")
	    if self.internal == nil then
	        return nil
	    end
	    return self
	end
	function Compass:getFacing()
	    return self.internal.getFacing()
	end
	function Compass:getName()
	    return self.internal.getName()
	end
	function Compass:getConfiguration()
	    return self.internal.getConfiguration()
	end
	return Compass
end
local utils_peripherals_Compass = MODULE_utils_peripherals_Compass()


function MODULE_turtle_Turtle()
	local Block   = utils_blocks_Block
	local Vector3 = utils_math_Vector3
	local Direction = utils_movement_Direction
	local Side = turtle_Side
	local Config = utils_config_Config
	local file = utils_other_file
	local Inventory = turtle_Inventory
	local Blocks    = utils_blocks_Blocks
	local Table = utils_data_Table
	local Compass = utils_peripherals_Compass
	local Turtle = {}
	Turtle.CONFIG = Config.load()
	function Turtle.getGpsPosition()
	    local x, y, z = gps.locate()
	    return Vector3.new(x, y, z)
	end
	Turtle.CURRENT_POSITION = Turtle.getGpsPosition()
	Turtle.CURRENT_DIRECTION = Turtle.CONFIG.homeDirection
	Turtle._UNCHECKED_DIRECTION = true  -- Used to determine if the direction has been checked
	local compass = Compass.new()
	if compass ~= nil then
	    print("Using compass to determine direction")
	    Turtle.CURRENT_DIRECTION = compass.getFacing()
	    Turtle._UNCHECKED_DIRECTION = false
	    print("Facing " .. Turtle.CURRENT_DIRECTION)
	end
	function Turtle.moveInDirection(direction)
	    Turtle.turnTo(direction)
	    if direction == Direction.UP then
	        return Turtle.up()
	    elseif direction == Direction.DOWN then
	        return Turtle.down()
	    else
	        return Turtle.forward()
	    end
	end
	function Turtle.forward()
	    local block = Turtle.getBlockInFront()
	    if block ~= nil and not Block.isLiquid(block.name) then
	        return false
	    end
	    local oldPosition = Turtle.CURRENT_POSITION:copy()
	    local moved = turtle.forward()
	    local expectedNewPosition = Turtle.CURRENT_POSITION:addInDirection(Turtle.CURRENT_DIRECTION, 1)
	    if not moved then
	        return false
	    end
	    if Turtle._UNCHECKED_DIRECTION then
	        local newPosition = Turtle.getGpsPosition()
	        if not newPosition:equals(expectedNewPosition) then
	            Turtle.CURRENT_DIRECTION = oldPosition:directionTo(newPosition)
	        end
	        Turtle.CURRENT_POSITION = newPosition
	        Turtle._UNCHECKED_DIRECTION = false  -- The direction is now known
	    else
	        Turtle.CURRENT_POSITION = expectedNewPosition
	    end
	    return true
	end
	function Turtle.back()
	    local block = Turtle.getBlockInFront()
	    if block ~= nil and not Block.isLiquid(block.name) then return false end
	    turtle.back()
	    Turtle.CURRENT_POSITION = Turtle.CURRENT_POSITION:addInOppositeDirection(Turtle.CURRENT_DIRECTION, 1)
	    return true
	end
	function Turtle.up()
	    local block = Turtle.getBlockAbove()
	    if block ~= nil and not Block.isLiquid(block.name) then return false end
	    turtle.up()
	    Turtle.CURRENT_POSITION = Turtle.CURRENT_POSITION:addInDirection(Direction.UP, 1)
	    return true
	end
	function Turtle.down()
	    local block = Turtle.getBlockBelow()
	    if block ~= nil and not Block.isLiquid(block.name) then return false end
	    turtle.down()
	    Turtle.CURRENT_POSITION = Turtle.CURRENT_POSITION:addInDirection(Direction.DOWN, 1)
	    return true
	end
	function Turtle.move(direction)
	    if direction == Direction.NORTH or direction == Direction.SOUTH or direction == Direction.WEST or direction == Direction.EAST then
	        Turtle.turnTo(direction)
	        return Turtle.forward()
	    elseif direction == Direction.UP then
	        return Turtle.up()
	    elseif direction == Direction.DOWN then
	        return Turtle.down()
	    else
	        print("Invalid direction")
	    end
	    return false
	end
	function Turtle.moveInRandomDirection()
	    local direction = math.random(1, 6)
	    if direction == 1 then
	        return Turtle.forward()
	    elseif direction == 2 then
	        return Turtle.up()
	    elseif direction == 3 then
	        return Turtle.down()
	    elseif direction == 4 then
	        Turtle.turnLeft()
	        return Turtle.forward()
	    elseif direction == 5 then
	        Turtle.turnRight()
	        return Turtle.forward()
	    else
	        return Turtle.back()
	    end
	end
	function Turtle.getFuelLevel()
	    return turtle.getFuelLevel()
	end
	function Turtle.refuel()
	    if Turtle.getFuelLevel() >= Turtle.CONFIG.fuelTarget then
	        return
	    end
	    local slot = nil
	    slot = 0
	    while Turtle.getFuelLevel() < Turtle.CONFIG.fuelTarget and slot ~= nil do
	        slot = Inventory.getSlotWithFuel()
	        if slot == nil then return end
	        turtle.select(slot)
	        turtle.refuel()
	    end
	end
	function Turtle.refuelUsingAdjacentContainer(targetFuelLevel, side)
	    local slot = nil
	    slot = 0
	    while Turtle.getFuelLevel() < targetFuelLevel and slot ~= nil do
	        print("*Fuel Level: " .. Turtle.getFuelLevel())
	        if side == nil then
	            side = Inventory.findContainerSide()
	            if side == nil then
	                os.sleep(1)
	            end
	        end
	        Turtle.turnToSide(side)
	        Inventory.pullFromContainer()
	        slot = Inventory.getSlotWithFuel()
	        if slot ~= nil then
	            turtle.select(slot)
	            turtle.refuel()
	        else
	            print("No fuel found")
	            os.sleep(1)
	        end
	    end
	    print("Current Fuel Level: " .. Turtle.getFuelLevel())
	end
	function Turtle.turnTo(direction)
	    local bestDirectionToTurn = Direction.getBestDirectionToTurn(Turtle.CURRENT_DIRECTION, direction)
	    if bestDirectionToTurn == Rotations.LEFT then
	        while Turtle.CURRENT_DIRECTION ~= direction do
	            Turtle.turnLeft()
	        end
	    elseif bestDirectionToTurn == Rotations.RIGHT then
	        while Turtle.CURRENT_DIRECTION ~= direction do
	            Turtle.turnRight()
	        end
	    end
	end
	function Turtle.turnToSide(side)
	    if side == Side.FRONT then
	        return
	    elseif side == Side.LEFT then
	        Turtle.turnLeft()
	    elseif side == Side.RIGHT then
	        Turtle.turnRight()
	    elseif side == Side.BACK then
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	    end
	end
	function Turtle.turnLeft()
	    turtle.turnLeft()
	    Turtle.CURRENT_DIRECTION = Direction.nextLeft(Turtle.CURRENT_DIRECTION)
	end
	function Turtle.turnRight()
	    turtle.turnRight()
	    Turtle.CURRENT_DIRECTION = Direction.nextRight(Turtle.CURRENT_DIRECTION)
	end
	function Turtle.goTo(destination)
	    local distance = destination:sub(Turtle.CURRENT_POSITION)
	    if distance.y > 0 then
	        for i = 1, distance.y do
	            turtle.up()
	        end
	    elseif distance.y < 0 then
	        for i = 1, math.abs(distance.y) do
	            turtle.down()
	        end
	    end
	    if distance.x > 0 then
	        Turtle.turnTo(Direction.EAST)
	        for i = 1, distance.x do
	            turtle.forward()
	        end
	    elseif distance.x < 0 then
	        Turtle.turnTo(Direction.WEST)
	        for i = 1, math.abs(distance.x) do
	            turtle.back()
	        end
	    end
	    if distance.z > 0 then
	        Turtle.turnTo(Direction.SOUTH)
	        for i = 1, distance.z do
	            turtle.forward()
	        end
	    elseif distance.z < 0 then
	        Turtle.turnTo(Direction.NORTH)
	        for i = 1, math.abs(distance.z) do
	            turtle.back()
	        end
	    end
	end
	function Turtle.goHome()
	    Turtle.goTo(Turtle.CONFIG.homePosition)
	    Turtle.turnTo(Turtle.CONFIG.homeDirection)
	end
	function Turtle.getBlockInFront()
	    local present, data = turtle.inspect()
	    if present == false then
	        return nil
	    end
	    local blockPosition = Turtle.CURRENT_POSITION:addInDirection(Turtle.CURRENT_DIRECTION, 1)
	    return Block.new(data.name, blockPosition, data.state, data.tags)
	end
	function Turtle.getBlockAbove()
	    local present, data = turtle.inspectUp()
	    if present == false then
	        return nil
	    end
	    local blockPosition = Turtle.CURRENT_POSITION:addInDirection(Direction.UP, 1)
	    return Block.new(data.name, blockPosition, data.state, data.tags)
	end
	function Turtle.getBlockBelow()
	    local present, data = turtle.inspectDown()
	    if present == false then
	        return nil
	    end
	    local blockPosition = Turtle.CURRENT_POSITION:addInDirection(Direction.DOWN, 1)
	    return Block.new(data.name, blockPosition, data.state, data.tags)
	end
	function Turtle.suck(count)
	    turtle.suck(count)
	end
	function Turtle.suckUp(count)
	    turtle.suckUp(count)
	end
	function Turtle.suckDown(count)
	    turtle.suckDown(count)
	end
	function Turtle.suckLeft(count)
	    Turtle.turnLeft()
	    Turtle.suck(count)
	    Turtle.turnRight()
	end
	function Turtle.suckRight(count)
	    Turtle.turnRight()
	    Turtle.suck(count)
	    Turtle.turnLeft()
	end
	function Turtle.suckBack(count)
	    Turtle.turnLeft()
	    Turtle.turnLeft()
	    Turtle.suck(count)
	    Turtle.turnLeft()
	    Turtle.turnLeft()
	end
	function Turtle.suckAll(count)
	    Turtle.suckUp(count)
	    Turtle.suckDown(count)
	    for i = 1, 4 do
	        Turtle.turnRight()
	        Turtle.suck(count)
	    end
	end
	function Turtle.tryDrop(slot, count)
	    local block = Turtle.getBlockInFront()
	    if block == nil then
	        return false
	    end
	    turtle.select(slot)
	    turtle.drop(count)
	    return true
	end
	function Turtle.tryDropUp(slot, count)
	    local block = Turtle.getBlockAbove()
	    if block == nil then
	        return false
	    end
	    turtle.select(slot)
	    turtle.dropUp(count)
	    return true
	end
	function Turtle.tryDropDown(slot, count)
	    local block = Turtle.getBlockBelow()
	    if block == nil then
	        return false
	    end
	    turtle.select(slot)
	    turtle.dropDown(count)
	    return true
	end
	function Turtle.tryDropAll(slot, count)
	    if Turtle.tryDropDown(slot, count) then
	        return true
	    elseif Turtle.tryDropUp(slot, count) then
	        return true
	    end
	    for i = 1, 4 do
	        Turtle.turnRight()
	        if Turtle.tryDrop(slot, count) then
	            return true
	        end
	    end
	    return false
	end
	function Turtle.dump(side)
	    if side == nil then
	        side = Inventory.findContainerSide()
	        if side == nil then
	            print("No dump container found - please place one")
	            os.sleep(1)
	        end
	    end
	    Turtle.turnToSide(side)
	    Inventory.dumpIntoContainer()
	end
	function Turtle.safeDig(direction)
	    local hasBlock = nil
	    local data = nil
	    if direction == nil then
	        hasBlock, data = turtle.inspect()
	    elseif direction == Direction.UP then
	        hasBlock, data = turtle.inspectUp()
	    elseif direction == Direction.DOWN then
	        hasBlock, data = turtle.inspectDown()
	    else
	        Turtle.turnTo(direction)
	        hasBlock, data = turtle.inspect()
	    end
	    if not hasBlock or data == nil then
	        return true
	    end
	    if Block.isAllowedToBreak(data.name) then
	        Turtle.dig(direction)
	        return true
	    else
	        return false
	    end
	end
	function Turtle.dig(direction)
	    if direction == nil then
	        turtle.dig()
	    elseif direction == Direction.UP then
	        turtle.digUp()
	    elseif direction == Direction.DOWN then
	        turtle.digDown()
	    else
	        Turtle.turnTo(direction)
	        turtle.dig()
	    end
	end
	function Turtle.select(slot)
	    if slot == nil then
	        return
	    end
	    turtle.select(slot)
	end
	function Turtle.digUp()
	    turtle.digUp()
	end
	function Turtle.digDown()
	    turtle.digDown()
	end
	function Turtle.place()
	    turtle.place()
	end
	function Turtle.placeUp()
	    turtle.placeUp()
	end
	function Turtle.placeDown()
	    turtle.placeDown()
	end
	return Turtle
end
local turtle_Turtle = MODULE_turtle_Turtle()


function MODULE_utils_jobutils_CommonStates()
	local ContainerPatternNames = utils_storage_patterns_ContainerPatternNames
	local Turtle = turtle_Turtle
	local Terminal = utils_terminal_Terminal
	local CommonStates = {}
	function CommonStates.onCommandPrompt(self)
	    local userInput = Terminal.read("\nEnter Command: ")
	    print("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
	    self.commands:run(userInput)
	end
	function CommonStates.onMoving(self)
	    local actionSide = self.config:get("actionSide", ContainerPatternNames.DIRECTION_FORWARD)
	    if actionSide == ContainerPatternNames.DIRECTION_UP then
	        Turtle.up()
	    elseif actionSide == ContainerPatternNames.DIRECTION_DOWN then
	        Turtle.down()
	    else
	        Turtle.forward()
	    end
	end
	return CommonStates
end
local utils_jobutils_CommonStates = MODULE_utils_jobutils_CommonStates()


function MODULE_utils_jobutils_CommonCodedInventoryListeners()
	local Turtle = turtle_Turtle
	local ContainerPatternNames = utils_storage_patterns_ContainerPatternNames
	local CommonCodedInventoryListeners = {}
	function CommonCodedInventoryListeners.defaultListener(self, name, side, count)
	    print("Ignoring pattern: " .. name)
	end
	function CommonCodedInventoryListeners.actionStop(self, name, side, count)
	    self.config:set("state", self.states.COMMAND_PROMPT)
	    self.config:set("alive", false)
	end
	function CommonCodedInventoryListeners.actionHome(self, name, side, count)
	    Turtle.goHome()
	    self.config:set("state", self.states.COMMAND_PROMPT)
	end
	function CommonCodedInventoryListeners.actionMove(self, name, side, count)
	    if side == ContainerPatternNames.DIRECTION_LEFT then
	        Turtle.turnLeft()
	    elseif side == ContainerPatternNames.DIRECTION_RIGHT then
	        Turtle.turnRight()
	    elseif side == ContainerPatternNames.DIRECTION_BACK then
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	    end
	    self.config:set("state", self.states.MOVING)
	    self.config:set("actionSide", side)
	end
	function CommonCodedInventoryListeners.actionBreak(self, name, side, count)
	    if side == ContainerPatternNames.DIRECTION_FORWARD then
	        Turtle.dig()
	    elseif side == ContainerPatternNames.DIRECTION_UP then
	        Turtle.digUp()
	    elseif side == ContainerPatternNames.DIRECTION_DOWN then
	        Turtle.digDown()
	    elseif side == ContainerPatternNames.DIRECTION_LEFT then
	        Turtle.turnLeft()
	        Turtle.dig()
	        Turtle.turnRight()
	    elseif side == ContainerPatternNames.DIRECTION_RIGHT then
	        Turtle.turnRight()
	        Turtle.dig()
	        Turtle.turnLeft()
	    elseif side == ContainerPatternNames.DIRECTION_BACK then
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	        Turtle.dig()
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	    end
	    self.config:set("state", self.states.COMMAND_PROMPT)
	end
	function CommonCodedInventoryListeners.actionPlace(self, name, side, count)
	    local slot = 1
	    turtle.select(slot)
	    if side == ContainerPatternNames.DIRECTION_FORWARD then
	        Turtle.place()
	    elseif side == ContainerPatternNames.DIRECTION_UP then
	        Turtle.placeUp()
	    elseif side == ContainerPatternNames.DIRECTION_DOWN then
	        Turtle.placeDown()
	    elseif side == ContainerPatternNames.DIRECTION_LEFT then
	        Turtle.turnLeft()
	        Turtle.place()
	        Turtle.turnRight()
	    elseif side == ContainerPatternNames.DIRECTION_RIGHT then
	        Turtle.turnRight()
	        Turtle.place()
	        Turtle.turnLeft()
	    elseif side == ContainerPatternNames.DIRECTION_BACK then
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	        Turtle.place()
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	    end
	    self.config:set("state", self.states.COMMAND_PROMPT)
	end
	function CommonCodedInventoryListeners.actionMarker(self, name, side, count)
	    local existingMarkers = self.config:get("markers", {})
	    existingMarkers[count] = Turtle.CURRENT_POSITION:copy():toTable()
	    self.config:set("markers", existingMarkers)
	    self.config:set("state", self.states.COMMAND_PROMPT)
	end
	function CommonCodedInventoryListeners.actionDrop(self, name, side, count)
	    local slot = 1
	    if side == ContainerPatternNames.DIRECTION_FORWARD then
	        Turtle.tryDrop(slot, count)
	    elseif side == ContainerPatternNames.DIRECTION_UP then
	        Turtle.tryDropUp(slot, count)
	    elseif side == ContainerPatternNames.DIRECTION_DOWN then
	        Turtle.tryDropDown(slot, count)
	    elseif side == ContainerPatternNames.DIRECTION_LEFT then
	        Turtle.turnLeft()
	        Turtle.tryDrop(slot, count)
	        Turtle.turnRight()
	    elseif side == ContainerPatternNames.DIRECTION_RIGHT then
	        Turtle.turnRight()
	        Turtle.tryDrop(slot, count)
	        Turtle.turnLeft()
	    elseif side == ContainerPatternNames.DIRECTION_BACK then
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	        Turtle.tryDrop(slot, count)
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	    end
	    self.config:set("state", self.states.COMMAND_PROMPT)
	end
	function CommonCodedInventoryListeners.actionSuck(self, name, side, count)
	    local slot = 1
	    turtle.select(slot)
	    if side == ContainerPatternNames.DIRECTION_FORWARD then
	        Turtle.suck(count)
	    elseif side == ContainerPatternNames.DIRECTION_UP then
	        Turtle.suckUp(count)
	    elseif side == ContainerPatternNames.DIRECTION_DOWN then
	        Turtle.suckDown(count)
	    elseif side == ContainerPatternNames.DIRECTION_LEFT then
	        Turtle.suckLeft(count)
	    elseif side == ContainerPatternNames.DIRECTION_RIGHT then
	        Turtle.suckRight(count)
	    elseif side == ContainerPatternNames.DIRECTION_BACK then
	        Turtle.suckBack(count)
	    end
	    self.config:set("state", self.states.COMMAND_PROMPT)
	end
	function CommonCodedInventoryListeners.actionRefuel(self, name, side, count)
	    local slot = 1
	    turtle.select(slot)
	    if side == ContainerPatternNames.DIRECTION_FORWARD then
	        Turtle.suck(count)
	    elseif side == ContainerPatternNames.DIRECTION_UP then
	        Turtle.suckUp(count)
	    elseif side == ContainerPatternNames.DIRECTION_DOWN then
	        Turtle.suckDown(count)
	    elseif side == ContainerPatternNames.DIRECTION_LEFT then
	        Turtle.suckLeft(count)
	    elseif side == ContainerPatternNames.DIRECTION_RIGHT then
	        Turtle.suckRight(count)
	    elseif side == ContainerPatternNames.DIRECTION_BACK then
	        Turtle.suckBack(count)
	    end
	    turtle.refuel()
	    self.config:set("state", self.states.COMMAND_PROMPT)
	end
	return CommonCodedInventoryListeners
end
local utils_jobutils_CommonCodedInventoryListeners = MODULE_utils_jobutils_CommonCodedInventoryListeners()


function MODULE_utils_data_ListUtils()
	local ListUtils = {}
	function ListUtils.toString(value)
	    if type(value) == "table" then
	        return textutils.serialise(value)
	    else
	        return tostring(value)
	    end
	end
	function ListUtils.notNil(value)
	    return value ~= nil
	end
	return ListUtils
end
local utils_data_ListUtils = MODULE_utils_data_ListUtils()


function MODULE_utils_data_Collections()
	local ListUtils = utils_data_ListUtils
	local Dict = {}
	Dict.__index = Dict
	Dict.TYPE = "Dict"
	local List = {}
	List.__index = List
	List.TYPE = "List"
	function Dict.new(data)
	    local self = setmetatable({}, {__index = Dict})
	    self.type = Dict.TYPE
	    self.data = data or {}
	    return self
	end
	function Dict.fromTable(data)
	    return Dict.new(data)
	end
	function Dict:toTable()
	    return self.data
	end
	function Dict:toList()
	    return self:items()
	end
	function Dict:toDict()
	    return self:copy()
	end
	function Dict.fromLists(keys, values)
	    if keys.type ~= List.TYPE then
	        error("Keys must be a List")
	    end
	    if values.type ~= List.TYPE then
	        error("Values must be a List")
	    end
	    local size = math.min(keys:size(), values:size())
	    local dict = Dict.new()
	    for index = 1, size do
	        dict:add(keys:get(index), values:get(index))
	    end
	    return dict
	end
	function Dict:copy()
	    local copy = Dict.new()
	    for key, value in pairs(self.data) do
	        copy:add(key, value)
	    end
	    return copy
	end
	function Dict:add(key, value)
	    self.data[key] = value
	    return self
	end
	function Dict:addAll(dict)
	    if dict.type ~= Dict.TYPE then
	        dict = dict.data
	    end
	    for key, value in pairs(dict) do
	        self:add(key, value)
	    end
	    return self
	end
	function Dict:remove(key)
	    self.data[key] = nil
	    return self
	end
	function Dict:contains(key)
	    return self.data[key] ~= nil
	end
	function Dict:containsKey(key)
	    return self:contains(key)
	end
	function Dict:containsValue(value)
	    for _, v in pairs(self.data) do
	        if v == value then
	            return true
	        end
	    end
	    return false
	end
	function Dict:get(key)
	    return self.data[key]
	end
	function Dict:getKey(value)
	    for k, v in pairs(self.data) do
	        if v == value then
	            return k
	        end
	    end
	    return nil
	end
	function Dict:keys()
	    local keys = List.new()
	    for key, _ in pairs(self.data) do
	        keys:add(key)
	    end
	    return keys
	end
	function Dict:values()
	    local values = List.new()
	    for _, value in pairs(self.data) do
	        values:add(value)
	    end
	    return values
	end
	function Dict:items()
	    local items = List.new()
	    for key, value in pairs(self.data) do
	        items:add({key = key, value = value})
	    end
	    return items
	end
	function Dict:clear()
	    self.data = {}
	end
	function Dict:size()
	    local count = 0
	    for _, _ in pairs(self.data) do
	        count = count + 1
	    end
	    return count
	end
	function Dict:isEmpty()
	    return self:size() == 0
	end
	function Dict:map(keyFunc, valueFunc)
	    if not valueFunc then
	        valueFunc = keyFunc
	        keyFunc = function(key, value) return key end
	    end
	    local results = Dict.new()
	    for key, value in pairs(self.data) do
	        results:add(keyFunc(key, value), valueFunc(key, value))
	    end
	    return results
	end
	function Dict:filter(func)
	    local results = Dict.new()
	    for key, value in pairs(self.data) do
	        if func(key, value) then
	            results:add(key, value)
	        end
	    end
	    return results
	end
	function Dict:reduce(func, initialValue)
	    local accumulator = initialValue
	    for key, value in pairs(self.data) do
	        accumulator = func(accumulator, key, value)
	    end
	    return accumulator
	end
	function Dict:forEach(func)
	    for key, value in pairs(self.data) do
	        func(key, value)
	    end
	end
	function Dict:first(default)
	    return self
	        :items()
	        :first(default)
	end
	function Dict:last(default)
	    return self
	        :items()
	        :last(default)
	end
	function Dict:join(separator)
	    return self
	        :items()
	        :join(separator)
	end
	function Dict:union(dict)
	    return self
	        :copy()
	        :addAll(dict)
	end
	function Dict:intersection(dict)
	    return self:filter(function(key, value) return dict:containsKey(key) and dict:get(key) == value end)
	end
	function Dict:sum()
	    return self:values():sum()
	end
	function Dict:product()
	    return self:values():product()
	end
	function Dict:min()
	    return self:values():min()
	end
	function Dict:max()
	    return self:values():max()
	end
	function Dict:average()
	    return self:values():average()
	end
	function Dict:mean()
	    return self:values():mean()
	end
	function Dict:median()
	    return self:values():median()
	end
	function Dict:mode()
	    return self:values():mode()
	end
	function Dict:sort()
	    print("Warning: Sorting a dictionary is not possible. Returning a copy of the dictionary.")
	    return self:copy()
	end
	function Dict:reverse()
	    print("Warning: Reversing a dictionary is not possible. Returning a copy of the dictionary.")
	    return self:copy()
	end
	function Dict:shuffle()
	    print("Warning: Shuffling a dictionary is not possible. Returning a copy of the dictionary.")
	    return self:copy()
	end
	function Dict:any(func)
	    return self:values():any(func)
	end
	function Dict:all(func)
	    return self:values():all(func)
	end
	function Dict:toString()
	    return textutils.serialise(self.data)
	end
	function List.new(data)
	    local self = setmetatable({}, {__index = List})
	    self.type = List.TYPE
	    self.data = data or {}
	    return self
	end
	function List.fromTable(data)
	    return List.new(data)
	end
	function List:toTable()
	    return self.data
	end
	function List:toList()
	    return self:copy()
	end
	function List:toDict()
	    local dict = Dict.new()
	    for i, v in ipairs(self.data) do
	        dict:add(v, i)
	    end
	    return dict
	end
	function List:copy()
	    local copy = List.new()
	    for i, v in ipairs(self.data) do
	        copy:add(v)
	    end
	    return copy
	end
	function List:add(value)
	    table.insert(self.data, value)
	    return self
	end
	function List:addAll(list)
	    if list.type ~= List.TYPE then
	        list = list.data
	    end
	    for i, v in ipairs(list) do
	        self:add(v)
	    end
	    return self
	end
	function List:insert(index, value)
	    table.insert(self.data, index, value)
	    return self
	end
	function List:removeByValue(value)
	    for i, v in ipairs(self.data) do
	        if v == value then
	            table.remove(self.data, i)
	            return self
	        end
	    end
	    return self
	end
	function List:removeByIndex(index)
	    table.remove(self.data, index)
	    return self
	end
	function List:contains(value)
	    for _, v in ipairs(self.data) do
	        if v == value then
	            return true
	        end
	    end
	    return false
	end
	function List:containsKey(index)
	    return self.data[index] ~= nil
	end
	function List:containsValue(value)
	    return self:contains(value)
	end
	function List:get(index)
	    return self.data[index]
	end
	function List:getKey(value)
	    for i, v in ipairs(self.data) do
	        if v == value then
	            return i
	        end
	    end
	    return nil
	end
	function List:keys()
	    local keys = List.new()
	    for i, _ in ipairs(self.data) do
	        keys:insert(i)
	    end
	    return keys
	end
	function List:values()
	    return self:copy()
	end
	function List:items()
	    local items = List.new()
	    for key, value in ipairs(self.data) do
	        items:insert({key = key, value = value})
	    end
	    return items
	end
	function List:clear()
	    self.data = {}
	    return self
	end
	function List:size()
	    return #self.data
	end
	function List:isEmpty()
	    return #self.data == 0
	end
	function List:map(func)
	    local results = List.new()
	    for i, v in ipairs(self.data) do
	        results:add(func(v))
	    end
	    return results
	end
	function List:flatMap(func)
	    local results = List.new()
	    for i, v in ipairs(self.data) do
	        local mapped = func(v)
	        if mapped.type == List.TYPE then
	            results:addAll(mapped)
	        else
	            results:add(mapped)
	        end
	    end
	    return results
	end
	function List:filter(func)
	    local results = List.new()
	    for i, v in ipairs(self.data) do
	        if func(v) then
	            results:add(v)
	        end
	    end
	    return results
	end
	function List:whereNil()
	    return self:filter(function(v) return v == nil end)
	end
	function List:whereNotNil()
	    return self:filter(function(v) return v ~= nil end)
	end
	function List:reduce(func, initialValue)
	    local accumulator = initialValue
	    for i, v in ipairs(self.data) do
	        accumulator = func(accumulator, v)
	    end
	    return accumulator
	end
	function List:forEach(func)
	    for i, v in ipairs(self.data) do
	        func(v)
	    end
	    return self
	end
	function List:first(default)
	    if self:isEmpty() then
	        return default
	    end
	    return self.data[1]
	end
	function List:last(default)
	    if self:isEmpty() then
	        return default
	    end
	    return self.data[#self.data]
	end
	function List:join(separator)
	    return table.concat(self:map(ListUtils.toString), separator)
	end
	function List:union(list)
	    return self
	        :copy()
	        :addAll(list:filter(function(v) return not self:contains(v) end))
	end
	function List:intersection(list)
	    return self:filter(function(v) return list:contains(v) end)
	end
	function List:sum()
	    return self:reduce(function(a, b) return a + b end, 0)
	end
	function List:product()
	    return self:reduce(function(a, b) return a * b end, 1)
	end
	function List:min()
	    return self:reduce(function(a, b) return math.min(a, b) end, math.huge)
	end
	function List:max()
	    return self:reduce(function(a, b) return math.max(a, b) end, -math.huge)
	end
	function List:average()
	    return self:sum() / self:size()
	end
	function List:mean()
	    return self:average()
	end
	function List:median()
	    local sorted = self:copy():sort()
	    local size = sorted:size()
	    if size % 2 == 0 then
	        return (sorted:get(size / 2) + sorted:get(size / 2 + 1)) / 2
	    else
	        return sorted:get(math.ceil(size / 2))
	    end
	end
	function List:mode()
	    local counts = Dict.new()
	    for i, v in ipairs(self.data) do
	        counts:add(v, (counts:get(v) or 0) + 1)
	    end
	    local maxCount = 0
	    local modes = List.new()
	    counts:forEach(function(k, v)
	        if v > maxCount then
	            modes:clear()
	            modes:add(k)
	            maxCount = v
	        elseif v == maxCount then
	            modes:add(k)
	        end
	    end)
	    return modes
	end
	function List:sort(func)
	    func = func or function(a, b) return a < b end
	    local sorted = self:copy()
	    table.sort(sorted.data, func)
	    return sorted
	end
	function List:reverse()
	    local reversed = List.new()
	    for i = #self.data, 1, -1 do
	        reversed:add(self.data[i])
	    end
	    return reversed
	end
	function List:shuffle()
	    local shuffled = self:copy()
	    for i = #shuffled.data, 1, -1 do
	        local j = math.random(1, i)
	        shuffled.data[i], shuffled.data[j] = shuffled.data[j], shuffled.data[i]
	    end
	    return shuffled
	end
	function List:any(func)
	    if not func then
	        for i, v in ipairs(self.data) do
	            if v then
	                return true
	            end
	        end
	    end
	    for i, v in ipairs(self.data) do
	        if func(v) then
	            return true
	        end
	    end
	    return false
	end
	function List:all(func)
	    if not func then
	        for i, v in ipairs(self.data) do
	            if not v then
	                return false
	            end
	        end
	    end
	    for i, v in ipairs(self.data) do
	        if not func(v) then
	            return false
	        end
	    end
	    return true
	end
	function List:zipWith(list, func)
	    local size = math.min(self:size(), list:size())
	    local zipped = List.new()
	    for i = 1, size do
	        zipped:add(func(self:get(i), list:get(i)))
	    end
	    return zipped
	end
	function List:unzip()
	    local list1 = List.new()
	    local list2 = List.new()
	    for i, v in ipairs(self.data) do
	        list1:add(v[1])
	        list2:add(v[2])
	    end
	    return list1, list2
	end
	function List:concat(list)
	    return self
	        :copy()
	        :addAll(list)
	end
	function List:flatten()
	    local flattened = List.new()
	    for i, v in ipairs(self.data) do
	        if type(v) == "table" then
	            if v.type ~= List.TYPE then v = List.new(v) end
	            flattened:addAll(v)
	        else
	            flattened:add(v)
	        end
	    end
	    return flattened
	end
	function List:groupBy(func)
	    local groups = Dict.new()
	    for i, v in ipairs(self.data) do
	        local key = func(v)
	        if not groups:containsKey(key) then
	            groups:add(key, List.new())
	        end
	        groups:get(key):add(v)
	    end
	    return groups
	end
	function List:skipFirst(count)
	    local skipped = List.new()
	    for i = count + 1, self:size() do
	        skipped:add(self.data[i])
	    end
	    return skipped
	end
	function List:takeFirst(count)
	    local taken = List.new()
	    for i = 1, math.min(count, self:size()) do
	        taken:add(self.data[i])
	    end
	    return taken
	end
	function List:skipLast(count)
	    local skipped = List.new()
	    for i = 1, self:size() - count do
	        skipped:add(self.data[i])
	    end
	    return skipped
	end
	function List:takeLast(count)
	    local taken = List.new()
	    for i = math.max(1, self:size() - count + 1), self:size() do
	        taken:add(self.data[i])
	    end
	    return taken
	end
	function List:splitAt(index)
	    return self:takeFirst(index), self:skipFirst(index)
	end
	function List:toString()
	    return textutils.serialise(self.data)
	end
	return {Dict = Dict, List = List}
end
local utils_data_Collections = MODULE_utils_data_Collections()


function MODULE_utils_storage_ContainerIndex()
	local ContainerIndex = {}
	ContainerIndex.__index = ContainerIndex
	function ContainerIndex.new(slotCount)
	    local self = setmetatable({}, ContainerIndex)
	    self.slotCount = slotCount
	    self.slotIndex = {}  -- slotIndex[slot] = {name = itemName, count = itemCount}
	    self.itemIndex = {}  -- itemIndex[itemName] = {slot1 = itemCount1, slot2 = itemCount2, ...}
	    return self
	end
	function ContainerIndex:addSlot(slot, itemName, itemCount)
	    self.slotIndex[slot] = {name = itemName, count = itemCount}
	    if self.itemIndex[itemName] == nil then
	        self.itemIndex[itemName] = {}
	    end
	    self.itemIndex[itemName][slot] = itemCount
	end
	function ContainerIndex:getSlot(slot)
	    local slotIndexValue = self.slotIndex[slot]
	    if slotIndexValue == nil then
	        return nil
	    end
	    return {slot = slot, name = slotIndexValue.name, count = slotIndexValue.count}
	end
	function ContainerIndex:getSlotWithItem(itemName)
	    local slots = self:getSlotsWithItem(itemName)
	    if #slots == 0 then
	        return nil
	    end
	    return slots[1]
	end
	function ContainerIndex:getSlotsWithItem(itemName)
	    local slots = {}
	    local itemSlots = self.itemIndex[itemName]
	    if itemSlots == nil then
	        return slots
	    end
	    for slot, itemCount in pairs(itemSlots) do
	        table.insert(slots, {slot = slot, name = itemName, count = itemCount})
	    end
	    return slots
	end
	function ContainerIndex:getEmptySlot()
	    for slot = 1, self.slotCount do
	        if self.slotIndex[slot] == nil then
	            return slot
	        end
	    end
	    return nil
	end
	function ContainerIndex:getEmptySlots()
	    local slots = {}
	    for slot = 1, self.slotCount do
	        if self.slotIndex[slot] == nil then
	            table.insert(slots, slot)
	        end
	    end
	    return slots
	end
	function ContainerIndex:getUsedSlots()
	    local slots = {}
	    for slot = 1, self.slotCount do
	        if self.slotIndex[slot] ~= nil then
	            table.insert(slots, slot)
	        end
	    end
	    return slots
	end
	function ContainerIndex:hasItem(itemName)
	    return self.itemIndex[itemName] ~= nil
	end
	function ContainerIndex:getItemDetail(itemName)
	    if not self:hasItem(itemName) then
	        return nil
	    end
	    local slots = self:getSlotsWithItem(itemName)
	    local itemCount = 0
	    for _, slot in pairs(slots) do
	        itemCount = itemCount + slot.count
	    end
	    return {name = itemName, count = itemCount, slots = slots}
	end
	function ContainerIndex:updateSlot(slot, itemName, itemCount)
	    if slot == nil then
	        error("Slot should not be nil")
	    end
	    if self.slotIndex[slot] == nil then
	        self:addSlot(slot, itemName, itemCount)
	    end
	    if self.itemIndex[itemName] == nil then
	        self.itemIndex[itemName] = {}
	    end
	    self.slotIndex[slot] = {name = itemName, count = itemCount}
	    self.itemIndex[itemName][slot] = itemCount
	    if itemCount == 0 then
	        self:removeSlot(slot)
	    end
	end
	function ContainerIndex:removeSlot(slot)
	    local itemName = self.slotIndex[slot].name
	    self.slotIndex[slot] = nil
	    self.itemIndex[itemName][slot] = nil
	end
	function ContainerIndex:getItemList()
	    local items = {}
	    for itemName, slots in pairs(self.itemIndex) do
	        local itemCount = 0
	        for slot, count in pairs(slots) do
	            itemCount = itemCount + count
	        end
	        table.insert(items, {name = itemName, count = itemCount})
	    end
	    return items
	end
	function ContainerIndex:getItemCount(name)
	    local slots = self:getSlotsWithItem(name)
	    local count = 0
	    for _, slot in pairs(slots) do
	        count = count + slot.count
	    end
	    return count
	end
	return ContainerIndex
end
local utils_storage_ContainerIndex = MODULE_utils_storage_ContainerIndex()


function MODULE_utils_blocks_BlockIndicators()
	local Blocks = utils_blocks_Blocks
	local BlockIndicators = {}
	BlockIndicators.INPUT = Blocks.green_wool
	BlockIndicators.OUTPUT = Blocks.red_wool
	BlockIndicators.KEEP_FILLED = Blocks.pink_wool
	BlockIndicators.SECONDARY_IO = Blocks.yellow_wool
	BlockIndicators.DIRECTION = Blocks.white_wool
	BlockIndicators.ACTION_STOP = Blocks.red_wool
	BlockIndicators.ACTION_HOME = Blocks.cyan_wool
	BlockIndicators.ACTION_MOVE = Blocks.green_wool
	BlockIndicators.ACTION_BREAK = Blocks.brown_wool
	BlockIndicators.ACTION_PLACE = Blocks.pink_wool
	BlockIndicators.ACTION_MARKER = Blocks.magenta_wool
	BlockIndicators.ACTION_DROP = Blocks.purple_wool
	BlockIndicators.ACTION_SUCK = Blocks.blue_wool
	BlockIndicators.ACTION_REFUEL = Blocks.black_wool
	return BlockIndicators
end
local utils_blocks_BlockIndicators = MODULE_utils_blocks_BlockIndicators()


function MODULE_utils_storage_patterns_ContainerPattern()
	local Blocks = utils_blocks_Blocks
	local ContainerPattern = {}
	ContainerPattern.__index = ContainerPattern
	ContainerPattern.indexes = {
	    [1] = {1, 2, 3, 10, 11, 12, 19, 20, 21},
	    [2] = {4, 5, 6, 13, 14, 15, 22, 23, 24},
	    [3] = {7, 8, 9, 16, 17, 18, 25, 26, 27},
	}
	function ContainerPattern.new(name, pattern)
	    local self = setmetatable({}, ContainerPattern)
	    self.name = name
	    self.pattern = pattern
	    return self
	end
	function ContainerPattern:match(containerIndex, positionToCheck)
	    if positionToCheck ~= nil then
	        if self:_matchWithOffset(containerIndex, positionToCheck) then
	            return {name = self.name, matchPosition = positionToCheck}
	        else
	            return nil
	        end
	    end
	    for offset = 1, 3 do
	        if self:_matchWithOffset(containerIndex, offset) then
	            return {name = self.name, matchPosition = offset, count = self:_getCount(containerIndex, offset)}
	        end
	    end
	    return nil
	end
	function ContainerPattern:_getCount(containerIndex, offset)
	    local index = {
	        [1] = 11,
	        [2] = 14,
	        [3] = 17,
	    }
	    local slot = containerIndex:getSlot(index[offset])
	    if slot == nil then
	        return 0
	    end
	    return slot.count
	end
	function ContainerPattern:_matchWithOffset(containerIndex, offset)
	    local indexes = ContainerPattern.indexes[offset]
	    for index = 1, 9 do
	        local patternSlotNumber = index
	        local containerSlotNumber = indexes[index]
	        local block = self.pattern[patternSlotNumber]
	        if block ~= nil and block ~= Blocks.ANY then
	            local slot = containerIndex:getSlot(containerSlotNumber)
	            if slot == nil or slot.name ~= block then
	                return nil
	            end
	        end
	    end
	    return true
	end
	return ContainerPattern
end
local utils_storage_patterns_ContainerPattern = MODULE_utils_storage_patterns_ContainerPattern()


function MODULE_utils_storage_patterns_ContainerPatterns()
	local BlockIndicators = utils_blocks_BlockIndicators
	local ContainerPattern = utils_storage_patterns_ContainerPattern
	local ContainerPatterns = {}
	ContainerPatterns.ACTION_STOP = ContainerPattern.new("ACTION_STOP", {[5] = BlockIndicators.ACTION_STOP})
	ContainerPatterns.ACTION_HOME = ContainerPattern.new("ACTION_HOME", {[5] = BlockIndicators.ACTION_HOME})
	ContainerPatterns.ACTION_MOVE = ContainerPattern.new("ACTION_MOVE", {[5] = BlockIndicators.ACTION_MOVE})
	ContainerPatterns.ACTION_BREAK = ContainerPattern.new("ACTION_BREAK", {[5] = BlockIndicators.ACTION_BREAK})
	ContainerPatterns.ACTION_PLACE = ContainerPattern.new("ACTION_PLACE", {[5] = BlockIndicators.ACTION_PLACE})
	ContainerPatterns.ACTION_MARKER = ContainerPattern.new("ACTION_MARKER", {[5] = BlockIndicators.ACTION_MARKER})
	ContainerPatterns.ACTION_DROP = ContainerPattern.new("ACTION_DROP", {[5] = BlockIndicators.ACTION_DROP})
	ContainerPatterns.ACTION_SUCK = ContainerPattern.new("ACTION_SUCK", {[5] = BlockIndicators.ACTION_SUCK})
	ContainerPatterns.ACTION_REFUEL = ContainerPattern.new("ACTION_REFUEL", {[5] = BlockIndicators.ACTION_REFUEL})
	return ContainerPatterns
end
local utils_storage_patterns_ContainerPatterns = MODULE_utils_storage_patterns_ContainerPatterns()


function MODULE_utils_storage_patterns_ContainerDirections()
	local Side = turtle_Side
	local BlockIndicators = utils_blocks_BlockIndicators
	local ContainerPattern = utils_storage_patterns_ContainerPattern
	local ContainerDirections = {}
	ContainerDirections.DIRECTION_UP = ContainerPattern.new(Side.TOP, {
	    [2] = BlockIndicators.DIRECTION,
	    [4] = BlockIndicators.DIRECTION,
	    [6] = BlockIndicators.DIRECTION,
	})
	ContainerDirections.DIRECTION_DOWN = ContainerPattern.new(Side.BOTTOM, {
	    [8] = BlockIndicators.DIRECTION,
	    [4] = BlockIndicators.DIRECTION,
	    [6] = BlockIndicators.DIRECTION,
	})
	ContainerDirections.DIRECTION_FORWARD = ContainerPattern.new(Side.FRONT, {[2] = BlockIndicators.DIRECTION})
	ContainerDirections.DIRECTION_BACK = ContainerPattern.new(Side.BACK, {[8] = BlockIndicators.DIRECTION})
	ContainerDirections.DIRECTION_LEFT = ContainerPattern.new(Side.LEFT, {[4] = BlockIndicators.DIRECTION})
	ContainerDirections.DIRECTION_RIGHT = ContainerPattern.new(Side.RIGHT, {[6] = BlockIndicators.DIRECTION})
	return ContainerDirections
end
local utils_storage_patterns_ContainerDirections = MODULE_utils_storage_patterns_ContainerDirections()


function MODULE_utils_storage_Container()
	local Table = utils_data_Table
	local Collections = utils_data_Collections
	local ContainerIndex = utils_storage_ContainerIndex
	local ContainerPatterns = utils_storage_patterns_ContainerPatterns
	local ContainerDirections = utils_storage_patterns_ContainerDirections
	local Container = {}
	Container.__index = Container
	function Container.new(name)
	    local self = setmetatable({}, Container)
	    self.name = name
	    self.internal = peripheral.wrap(name)
	    if self.internal == nil then
	        return nil
	    end
	    self.size = self:_getInternalSize()
	    self.index = ContainerIndex.new(self.size)
	    self:updateIndex()
	    return self
	end
	function Container:_getInternalSize()
	    if self.internal == nil then
	        return 0
	    elseif self.internal.size == nil then
	        return 0
	    end
	    return self.internal.size()
	end
	function Container:_getInternalList()
	    if self.internal == nil then
	        return {}
	    elseif self.internal.list == nil then
	        return {}
	    end
	    return self.internal.list()
	end
	function Container:updateIndex()
	    if self.internal == nil then
	        return
	    end
	    self.index = ContainerIndex.new(self.size)
	    for slot, item in pairs(self:_getInternalList()) do
	        self.index:addSlot(slot, item.name, item.count)
	    end
	end
	function Container:hasItem(itemName)
	    return self.index:hasItem(itemName)
	end
	function Container:getItemLimit(slotNumber)
	    if self.internal == nil then
	        return 0
	    end
	    return self.internal.getItemLimit(slotNumber)
	end
	function Container:putItems(sourceContainer, itemName, count)
	    if self.internal == nil or sourceContainer.internal == nil then
	        return count
	    end
	    local destContainer = self
	    local remainingCount = self:_putItemsLoop(sourceContainer, destContainer, itemName, count)
	    destContainer:updateIndex()
	    return remainingCount
	end
	function Container:_putItemsLoop(sourceContainer, destContainer, itemName, count)
	    local remainingCount = count
	    local slotsWithItem = sourceContainer:findItemSlots(itemName)
	    for _, slotWithItem in pairs(slotsWithItem) do
	        local moved = sourceContainer.internal.pushItems(destContainer.name, slotWithItem.slot, remainingCount)
	        remainingCount = remainingCount - moved  -- Track the remaining count
	        if moved == 0 or remainingCount == 0 then
	            return remainingCount
	        end
	        sourceContainer.index:updateSlot(slotWithItem.slot, itemName, slotWithItem.count - moved)
	    end
	    return remainingCount
	end
	function Container:sendItems(destinationContainer, itemName, count)
	    local sourceContainer = self
	    return destinationContainer:putItems(sourceContainer, itemName, count)
	end
	function Container:findItemSlot(itemName)
	    return self.index:getSlotWithItem(itemName)
	end
	function Container:findItemSlots(itemName)
	    return self.index:getSlotsWithItem(itemName)
	end
	function Container:getItemCount(slotOrItemName)
	    local item = self.index:getSlot(slotOrItemName)
	    if item ~= nil then
	        return item.count
	    end
	    local count = self.index:getItemCount(slotOrItemName)
	    if count ~= nil then
	        return count
	    end
	    return 0  -- Not found
	end
	function Container:getSlot(slot)
	    return self.index:getSlot(slot)
	end
	function Container:getEmptySlot()
	    return self.index:getEmptySlot()
	end
	function Container:getEmptySlots()
	    return self.index:getEmptySlots()
	end
	function Container:getUsedSlots()
	    return self.index:getUsedSlots()
	end
	function Container:getItemList()
	    return self.index:getItemList()
	end
	function Container:getMaxCount(slot)
	    if self.internal == nil then
	        return 0
	    end
	    local itemDetail = self.internal.getItemDetail(slot)
	    if itemDetail == nil then
	        return self:getItemLimit(slot)
	    end
	    return itemDetail.maxCount
	end
	function Container:defragment()
	    if self.internal == nil then
	        return
	    end
	    local items = self:getItemList()
	    for _, item in pairs(items) do
	        self:_defragmentSingleItem(item)
	    end
	end
	function Container:_defragmentSingleItem(item)
	    local slots = self:findItemSlots(item.name)
	    slots = Collections.List.new(slots)
	    if slots:size() == 0 then
	        return
	    end
	    local maxCount = self:getMaxCount(slots:first().slot)
	    slots = slots:filter(function(slot) return slot.count < maxCount end)
	    if slots:size() <= 1 then
	        return
	    end
	    slots
	        :skipFirst(1)
	        :reverse()
	        :map(function (slot)
	            local moved = self.internal.pushItems(self.name, slot.slot)
	            if moved > 0 then
	                self.index:updateSlot(slot.slot, item.name, slot.count - moved)
	            end
	        end)
	end
	function Container:tostring()
	    return self.name
	end
	function Container:getMatchingContainerPatterns()
	    if self.internal == nil then
	        return nil
	    end
	    local matchingPatterns = {}
	    for _, pattern in pairs(ContainerPatterns) do
	        local match = pattern:match(self.index)
	        if match ~= nil then
	            local direction = nil
	            for _, directionPattern in pairs(ContainerDirections) do
	                local directionMatch = directionPattern:match(self.index, match.matchPosition)
	                if directionMatch ~= nil then
	                    direction = directionMatch
	                end
	            end
	            if direction == nil then
	                match.direction = nil
	            else
	                match.direction = direction.name
	            end
	            matchingPatterns[match.matchPosition] = match
	        end
	    end
	    if Table.isEmpty(matchingPatterns) then
	        return nil
	    end
	    local newMatchingPatterns = {}
	    for _, match in pairs(matchingPatterns) do
	        table.insert(newMatchingPatterns, match)
	    end
	    return newMatchingPatterns
	end
	return Container
end
local utils_storage_Container = MODULE_utils_storage_Container()


function MODULE_utils_storage_codedinventory_CodedInventory()
	local CommonCodedInventoryListeners = utils_jobutils_CommonCodedInventoryListeners
	local ContainerPatternNames = utils_storage_patterns_ContainerPatternNames
	local Turtle = turtle_Turtle
	local Blocks = utils_blocks_Blocks
	local Side = turtle_Side
	local Container = utils_storage_Container
	local CodedInventory = {}
	CodedInventory.__index = CodedInventory
	function CodedInventory.new()
	    local self = setmetatable({}, CodedInventory)
	    self.listeners = {}
	    self.defaultListener = nil
	    return self
	end
	function CodedInventory:addListener(patternName, listenerFunction)
	    self.listeners[patternName] = listenerFunction
	end
	function CodedInventory:addDefaultListeners()
	    self.defaultListener = CommonCodedInventoryListeners.defaultListener
	    self:addListener(ContainerPatternNames.ACTION_STOP, CommonCodedInventoryListeners.actionStop)
	    self:addListener(ContainerPatternNames.ACTION_HOME, CommonCodedInventoryListeners.actionHome)
	    self:addListener(ContainerPatternNames.ACTION_MOVE, CommonCodedInventoryListeners.actionMove)
	    self:addListener(ContainerPatternNames.ACTION_BREAK, CommonCodedInventoryListeners.actionBreak)
	    self:addListener(ContainerPatternNames.ACTION_PLACE, CommonCodedInventoryListeners.actionPlace)
	    self:addListener(ContainerPatternNames.ACTION_MARKER, CommonCodedInventoryListeners.actionMarker)
	    self:addListener(ContainerPatternNames.ACTION_DROP, CommonCodedInventoryListeners.actionDrop)
	    self:addListener(ContainerPatternNames.ACTION_SUCK, CommonCodedInventoryListeners.actionSuck)
	    self:addListener(ContainerPatternNames.ACTION_REFUEL, CommonCodedInventoryListeners.actionRefuel)
	end
	function CodedInventory:notifyListeners(jobSelf, patternName, side, count)
	    if self.listeners[patternName] ~= nil then
	        self.listeners[patternName](jobSelf, patternName, side, count)
	        return
	    end
	    if self.defaultListener ~= nil then
	        self.defaultListener(jobSelf, patternName, side, count)
	        return
	    end
	    print("WARNING: No listener found for pattern '" .. patternName .. "'")
	end
	function CodedInventory:getInventories()
	    local codedInventories = {
	        [Side.TOP] = Container.new(Side.TOP),
	        [Side.BOTTOM] = Container.new(Side.BOTTOM),
	    }
	    local presentInventories = {}
	    for side, container in pairs(codedInventories) do
	        if container ~= nil then
	            presentInventories[side] = container
	        end
	    end
	    return presentInventories
	end
	function CodedInventory:getMatchingPatterns()
	    local containers = self:getInventories()
	    local allPatterns = {}
	    for _, container in pairs(containers) do
	        local matchingPatterns = container:getMatchingContainerPatterns()
	        if matchingPatterns ~= nil then
	            for _, pattern in pairs(matchingPatterns) do
	                table.insert(allPatterns, pattern)
	            end
	        end
	    end
	    if #allPatterns == 0 then
	        return nil
	    end
	    return allPatterns
	end
	function CodedInventory:run(jobSelf)
	    local patterns = self:getMatchingPatterns()
	    if patterns == nil then
	        return
	    end
	    for _, pattern in pairs(patterns) do
	        self:notifyListeners(jobSelf, pattern.name, pattern.direction, pattern.count)
	    end
	end
	return CodedInventory
end
local utils_storage_codedinventory_CodedInventory = MODULE_utils_storage_codedinventory_CodedInventory()


function MODULE_utils_jobutils_CommonEventImplementations()
	local Network = utils_network_Network
	local CommonEventImplementations = {}
	local function onStepBase(self)
	    local state = self.config:get("state", self.states.COMMAND_PROMPT)
	    local stateAction = self.stateActions[state]
	    if stateAction == nil then
	        print("Invalid state: " .. state)
	        self.config:set("state", self.states.COMMAND_PROMPT)
	        return
	    end
	    stateAction(self)
	end
	function CommonEventImplementations.onStart(self)
	    return self.config:set("alive", true)
	end
	function CommonEventImplementations.onResume(self)
	    return
	end
	function CommonEventImplementations.inProgress(self)
	    return self.config:get("alive", false)
	end
	function CommonEventImplementations.onStepStatic(self)
	    return onStepBase(self)
	end
	function CommonEventImplementations.onStepMobile(self)
	    self.codedInventory:run(self)
	    return onStepBase(self)
	end
	function CommonEventImplementations.onStepTablet(self)
	    return onStepBase(self)
	end
	function CommonEventImplementations.onBackgroundStep(self)
	    return
	end
	function CommonEventImplementations.onComplete(self)
	    return
	end
	return CommonEventImplementations
end
local utils_jobutils_CommonEventImplementations = MODULE_utils_jobutils_CommonEventImplementations()


function MODULE_jobs_definitions_mobile_treeFarm_TreeFarmCodedInventoryListeners()
	local Turtle = turtle_Turtle
	local Inventory = turtle_Inventory
	local ContainerPatternNames = utils_storage_patterns_ContainerPatternNames
	local Text = utils_text_Text
	local LibOs = utils_libs_LibOs
	local TreeFarmCodedInventoryListeners = {}
	function TreeFarmCodedInventoryListeners.actionHome(self, name, side, count)
	    self.log("Home Detected - Watiting")
	    local waitSeconds = self.config:get("waitSeconds", 15)
	    os.sleep(waitSeconds)
	end
	function TreeFarmCodedInventoryListeners.actionMove(self, name, side, count)
	    local originalDirection = Turtle.CURRENT_DIRECTION
	    self.log("Turning to side: " .. side)
	    if side == ContainerPatternNames.DIRECTION_FORWARD then
	        self.config:set("state", self.states.TREE_FARM_MOVING_FORWARD)
	    elseif side == ContainerPatternNames.DIRECTION_LEFT then
	        Turtle.turnLeft()
	        self.config:set("state", self.states.TREE_FARM_MOVING_FORWARD)
	    elseif side == ContainerPatternNames.DIRECTION_RIGHT then
	        Turtle.turnRight()
	        self.config:set("state", self.states.TREE_FARM_MOVING_FORWARD)
	    elseif side == ContainerPatternNames.DIRECTION_BACK then
	        Turtle.turnLeft()
	        Turtle.turnLeft()
	        self.config:set("state", self.states.TREE_FARM_MOVING_FORWARD)
	    else
	        self.log("Unexpected direction: " .. side)
	    end
	    local block = Turtle.getBlockInFront()
	    while block ~= nil and Text.contains(block.name, "computercraft:turtle") do
	        self.log("There is another turtle in the way - waiting")
	        LibOs.sleep(1)
	        block = Turtle.getBlockInFront()
	    end
	end
	function TreeFarmCodedInventoryListeners.actionDrop(self, name, side, count)
	    self.log("Dumping items")
	    local originalDirection = Turtle.CURRENT_DIRECTION
	    Turtle.dump(side)
	    Turtle.turnTo(originalDirection)
	end
	function TreeFarmCodedInventoryListeners.actionSuck(self, name, side, count)
	    local originalDirection = Turtle.CURRENT_DIRECTION
	    local saplingTarget = self.config:get("saplingTarget", 128)
	    local currentSaplingCount = Inventory.countSaplings()
	    Turtle.turnToSide(side)
	    while currentSaplingCount < saplingTarget do
	        self.log("Sapling Count: " .. currentSaplingCount)
	        Turtle.suck()
	        currentSaplingCount = Inventory.countSaplings()
	    end
	    self.log("Sapling Count: " .. currentSaplingCount)
	    Turtle.turnTo(originalDirection)
	end
	function TreeFarmCodedInventoryListeners.actionRefuel(self, name, side, count)
	    self.log("Refueling")
	    local fuelTarget = self.config:get("targetFuelLevel", 1024)
	    local originalDirection = Turtle.CURRENT_DIRECTION
	    Turtle.refuelUsingAdjacentContainer(fuelTarget, side)
	    Turtle.turnTo(originalDirection)
	end
	return TreeFarmCodedInventoryListeners
end
local jobs_definitions_mobile_treeFarm_TreeFarmCodedInventoryListeners = MODULE_jobs_definitions_mobile_treeFarm_TreeFarmCodedInventoryListeners()


function MODULE_utils_network_protocols_logging_LogProtocol()
	local Terminal = utils_terminal_Terminal
	local Network = utils_network_Network
	local LibOs = utils_libs_LibOs
	local LogProtocol = {}
	LogProtocol.__index = LogProtocol
	function LogProtocol.new(job, onLogFunc)
	    local self = setmetatable({}, LogProtocol)
	    self.job = job  -- The job instance that is using this protocol
	    self.onLogFunc = onLogFunc
	    self.protocolName = "protocol:log"
	    self.commands = {
	        LOG = "LOG",
	    }
	    self.listeners = {
	        LOG = self.onLog,
	    }
	    self.histories = {}
	    return self
	end
	function LogProtocol:listen()
	    Network.host(self.protocolName)
	    Network.listen(self.protocolName, nil, function(senderId, message)
	        if type(message) ~= "table" then return end
	        local command = message.command
	        local args = message.message
	        local listener = self.listeners[command]
	        if listener == nil then return end
	        listener(self, args)
	    end)
	end
	function LogProtocol:_send(command, message)
	    Network.broadcast({
	        command = command,
	        message = message,
	    }, self.protocolName)
	end
	function LogProtocol:sendLog(...)
	    self:_send(self.commands.LOG, {sourceName = self.job.name, printArgs = ...})
	end
	function LogProtocol:sendLogToChannel(channel, ...)
	    self:_send(self.commands.LOG, {sourceName = channel, printArgs = ...})
	end
	function LogProtocol:onLog(args)
	    local sourceName = args.sourceName
	    local printArgs = args.printArgs
	    self.histories[sourceName] = self.histories[sourceName] or {}
	    table.insert(self.histories[sourceName], printArgs)
	    while #self.histories[sourceName] > 20 do
	        table.remove(self.histories[sourceName], 1)
	    end
	    if self.onLogFunc == nil then return end
	    self.onLogFunc(sourceName, printArgs)
	end
	function LogProtocol:display(sourceName)
	    for _ = 1, 20 do print() end
	    local history = self.histories[sourceName] or {}
	    for _, printArgs in ipairs(history) do
	        if type(printArgs) == "table" then
	            printArgs = table.concat(printArgs, " ")
	        end
	        print(printArgs)
	    end
	    Terminal.writeLineBreak()
	    print(sourceName)
	    print("            *Any Key Exit")
	end
	local function viewLogs(self, commandSourceName)
	    self.job.protocols.log.onLogFunc = function(updatedSourceName, ...)
	        if commandSourceName == updatedSourceName then
	            self.job.protocols.log:display(commandSourceName)
	        end
	    end
	    self.job.protocols.log.onLogFunc(commandSourceName)
	    while true do
	        LibOs.sleep(1)
	    end
	end
	function LogProtocol:view(sourceName)
	    parallel.waitForAny(
	        function() viewLogs(self, sourceName) end,
	        function() Terminal.waitForKey() end
	    )
	    self.job.protocols.log.onLogFunc = nil
	end
	return LogProtocol
end
local utils_network_protocols_logging_LogProtocol = MODULE_utils_network_protocols_logging_LogProtocol()


function MODULE_utils_other_Me()
	return {
	    username = "3p0",
	}
end
local utils_other_Me = MODULE_utils_other_Me()


function MODULE_utils_peripherals_PlayerDetector()
	local Table = utils_data_Table
	local PlayerDetector = {}
	PlayerDetector.detector = peripheral.find("playerDetector")
	function PlayerDetector.onPlayerClick(func)
	    while true do
	        local event, username, device = os.pullEvent("playerClick")
	        func(event, username, device)
	    end
	end
	function PlayerDetector.onPlayerJoin(func)
	    while true do
	        local event, username, dimension = os.pullEvent("playerJoin")
	        func(event, username, dimension)
	    end
	end
	function PlayerDetector.onPlayerLeave(func)
	    while true do
	        local event, username, dimension = os.pullEvent("playerLeave")
	        func(event, username, dimension)
	    end
	end
	function PlayerDetector.onPlayerEnterRange(func, range, period)
	    local oldPlayers = {}
	    while true do
	        os.sleep(period)
	        local newPlayers = PlayerDetector.getPlayersInRange(range)
	        local playersAdded = {}
	        for _, player in ipairs(newPlayers) do
	            if not Table.contains(oldPlayers, player) then
	                table.insert(playersAdded, player)
	            end
	        end
	        func(playersAdded)
	    end
	end
	function PlayerDetector.onPlayerLeaveRange(func, range, period)
	    local oldPlayers = {}
	    while true do
	        os.sleep(period)
	        local newPlayers = PlayerDetector.getPlayersInRange(range)
	        local playersRemoved = {}
	        for _, player in ipairs(oldPlayers) do
	            if not Table.contains(newPlayers, player) then
	                table.insert(playersRemoved, player)
	            end
	        end
	        func(playersRemoved)
	    end
	end
	function PlayerDetector.onPlayerChangedDimension(func)
	    while true do
	        local event, username, fromDim, toDim = os.pullEvent("playerChangedDimension")
	        func(event, username, fromDim, toDim)
	    end
	end
	function PlayerDetector.onPlayerMoved(func, username, period)
	    if username == nil then error("No username provided to PlayerDetector.onPlayerMoved") end
	    if period == nil then period = 5 end  -- Default period of 5 seconds
	    local oldPosition = PlayerDetector.getPlayer(username)
	    while true do
	        os.sleep(period)
	        local newPosition = PlayerDetector.getPlayer(username)
	        if oldPosition.x ~= newPosition.x or oldPosition.y ~= newPosition.y or oldPosition.z ~= newPosition.z then
	            func(username, oldPosition, newPosition)
	            oldPosition = newPosition
	        end
	    end
	end
	function PlayerDetector.getPlayer(username)
	    return PlayerDetector.detector.getPlayer(username)
	end
	function PlayerDetector.getOnlinePlayers()
	    return PlayerDetector.detector.getOnlinePlayers()
	end
	function PlayerDetector.getPlayersInRange(range)
	    return PlayerDetector.detector.getPlayersInRange(range)
	end
	function PlayerDetector.getPlayersInCoords(firstPosition, secondPosition)
	    return PlayerDetector.detector.getPlayersInCoords(firstPosition, secondPosition)
	end
	function PlayerDetector.getPlayersInCubic(width, height, depth)
	    return PlayerDetector.detector.getPlayersInCubic(width, height, depth)
	end
	function PlayerDetector.isPlayerInRange(range, username)
	    return PlayerDetector.detector.isPlayerInRange(range, username)
	end
	function PlayerDetector.isPlayerInCoords(firstPosition, secondPosition, username)
	    return PlayerDetector.detector.isPlayerInCoords(firstPosition, secondPosition, username)
	end
	function PlayerDetector.isPlayerInCubic(width, height, depth, username)
	    return PlayerDetector.detector.isPlayerInCubic(width, height, depth, username)
	end
	function PlayerDetector.isPlayersInRange(range)
	    return PlayerDetector.detector.isPlayersInRange(range)
	end
	function PlayerDetector.isPlayersInCoords(firstPosition, secondPosition)
	    return PlayerDetector.detector.isPlayerInCoords(firstPosition, secondPosition)
	end
	function PlayerDetector.isPlayersInCubic(width, height, depth)
	    return PlayerDetector.detector.isPlayersInCubic(width, height, depth)
	end
	return PlayerDetector
end
local utils_peripherals_PlayerDetector = MODULE_utils_peripherals_PlayerDetector()


function MODULE_utils_network_protocols_remoteperipherals_PlayerProtocol()
	local Network = utils_network_Network
	local PlayerDetector = utils_peripherals_PlayerDetector
	local PlayerProtocol = {}
	PlayerProtocol.__index = PlayerProtocol
	function PlayerProtocol.new(job)
	    local self = setmetatable({}, PlayerProtocol)
	    self.job = job  -- The job instance that is using this protocol
	    self.protocolName = "protocol:player"
	    self.commands = {
	        GET_PLAYER = "GET_PLAYER",
	        GET_PLAYER_RESPONSE = "GET_PLAYER_RESPONSE",
	        GET_ONLINE_PLAYERS = "GET_ONLINE_PLAYERS",
	        GET_ONLINE_PLAYERS_RESPONSE = "GET_ONLINE_PLAYERS_RESPONSE",
	        GET_PLAYERS_IN_COORDS = "GET_PLAYERS_IN_COORDS",
	        GET_PLAYERS_IN_COORDS_RESPONSE = "GET_PLAYERS_IN_COORDS_RESPONSE",
	    }
	    self.listeners = {
	        [self.commands.GET_PLAYER] = self.onGetPlayer,
	        [self.commands.GET_PLAYER_RESPONSE] = self.onGetPlayerResponse,
	        [self.commands.GET_ONLINE_PLAYERS] = self.onGetOnlinePlayers,
	        [self.commands.GET_ONLINE_PLAYERS_RESPONSE] = self.onGetOnlinePlayersResponse,
	        [self.commands.GET_PLAYERS_IN_COORDS] = self.onGetPlayersInCoords,
	        [self.commands.GET_PLAYERS_IN_COORDS_RESPONSE] = self.onGetPlayersInCoordsResponse,
	    }
	    return self
	end
	function PlayerProtocol:listen()
	    Network.host(self.protocolName)
	    Network.listen(self.protocolName, nil, function(senderId, message)
	        if type(message) ~= "table" then return end
	        local command = message.command
	        local args = message.message
	        local listener = self.listeners[command]
	        if listener == nil then return end
	        listener(self, args)
	    end)
	end
	function PlayerProtocol:_send(command, message)
	    Network.broadcast({
	        command = command,
	        message = message,
	    }, self.protocolName)
	end
	function PlayerProtocol:sendGetPlayer(username)
	    self:_send(self.commands.GET_PLAYER, {username = username})
	    return Network.waitForResponse(self, self.commands.GET_PLAYER)
	end
	function PlayerProtocol:onGetPlayer(args)
	    local username = args.username
	    if PlayerDetector.detector ~= nil then
	        local player = PlayerDetector.getPlayer(username)
	        self:sendGetPlayerResponse(player)
	    end
	end
	function PlayerProtocol:sendGetPlayerResponse(player)
	    self:_send(self.commands.GET_PLAYER_RESPONSE, {player = player})
	end
	function PlayerProtocol:onGetPlayerResponse(args)
	    local player = args.player
	    Network.postResponse(self, self.commands.GET_PLAYER, player)
	end
	function PlayerProtocol:sendGetOnlinePlayers()
	    self:_send(self.commands.GET_ONLINE_PLAYERS, {})
	    return Network.waitForResponse(self, self.commands.GET_ONLINE_PLAYERS)
	end
	function PlayerProtocol:onGetOnlinePlayers(args)
	    local players = PlayerDetector.getOnlinePlayers()
	    self:sendGetOnlinePlayersResponse(players)
	end
	function PlayerProtocol:sendGetOnlinePlayersResponse(players)
	    self:_send(self.commands.GET_ONLINE_PLAYERS_RESPONSE, {players = players})
	end
	function PlayerProtocol:onGetOnlinePlayersResponse(args)
	    local players = args.players
	    Network.postResponse(self, self.commands.GET_ONLINE_PLAYERS, players)
	end
	function PlayerProtocol:sendGetPlayersInCoords(coords)
	    self:_send(self.commands.GET_PLAYERS_IN_COORDS, {coords = coords})
	    return Network.waitForResponse(self, self.commands.GET_PLAYERS_IN_COORDS)
	end
	function PlayerProtocol:onGetPlayersInCoords(args)
	    local coords = args.coords
	    local players = PlayerDetector.getPlayersInCoords(coords)
	    self:sendGetPlayersInCoordsResponse(players)
	end
	function PlayerProtocol:sendGetPlayersInCoordsResponse(players)
	    self:_send(self.commands.GET_PLAYERS_IN_COORDS_RESPONSE, {players = players})
	end
	function PlayerProtocol:onGetPlayersInCoordsResponse(args)
	    local players = args.players
	    Network.postResponse(self, self.commands.GET_PLAYERS_IN_COORDS, players)
	end
	return PlayerProtocol
end
local utils_network_protocols_remoteperipherals_PlayerProtocol = MODULE_utils_network_protocols_remoteperipherals_PlayerProtocol()


function MODULE_jobs_definitions_mobile_follower_FollowerStates()
	local Vector3 = utils_math_Vector3
	local Turtle = turtle_Turtle
	local FollowerStates = {}
	function FollowerStates.onFollowingTarget(self)
	    local targetPlayer = self.config:get("targetPlayer")
	    if targetPlayer == nil then
	        self.log("No target to follow")
	        self.config:set("state", self.states.FINDING_TARGET)
	        return
	    end
	    local player = self.protocols.player:sendGetPlayer(targetPlayer)
	    if player == nil then
	        self.log("Unable to get player")
	        self.config:set("state", self.states.FINDING_TARGET)
	        return
	    end
	    local playerPosition = Vector3.new(player)
	    playerPosition = playerPosition:add(Vector3.randint(
	        Vector3.new(-3, -1, -3),
	        Vector3.new(3, 2, 3)
	    ))
	    local direction = nil
	    local displacement = nil
	    local distance = playerPosition:distanceTo(Turtle.CURRENT_POSITION)
	    if distance > 11 then
	        self.log("Target is moving to target")
	        displacement = playerPosition:sub(Turtle.CURRENT_POSITION)
	        direction = Turtle.CURRENT_POSITION:horizontalDirectionTo(playerPosition)
	    elseif distance < 4 then
	        self.log("Target is too close - moving away from target")
	        displacement = playerPosition:sub(Turtle.CURRENT_POSITION)
	        direction = playerPosition:horizontalDirectionTo(Turtle.CURRENT_POSITION)
	    else
	        self.log("Turtle is at acceptable distance")
	        return
	    end
	    if direction ~= nil then
	        Turtle.turnTo(direction)
	    end
	    local tolerance = 2
	    local targetHeight = playerPosition.y + 3
	    if Turtle.CURRENT_POSITION.y < targetHeight - tolerance then
	        Turtle.up()
	    elseif Turtle.CURRENT_POSITION.y > targetHeight + tolerance then
	        Turtle.down()
	    end
	    if displacement.x ~= 0 or displacement.z ~= 0 then
	        local moved = Turtle.forward()
	        if not moved then
	            Turtle.moveInRandomDirection()
	            Turtle.moveInRandomDirection()
	        end
	    end
	end
	return FollowerStates
end
local jobs_definitions_mobile_follower_FollowerStates = MODULE_jobs_definitions_mobile_follower_FollowerStates()


function MODULE_jobs_definitions_mobile_follower_FollowerJob()
	local Commands = utils_terminal_commands_Commands
	local Command = utils_terminal_commands_Command
	local TreeFarmCommands = jobs_definitions_mobile_treeFarm_TreeFarmCommands
	local CommonCommands = utils_jobutils_CommonCommands
	local CommonStates = utils_jobutils_CommonStates
	local CodedInventory = utils_storage_codedinventory_CodedInventory
	local CommonEventImplementations = utils_jobutils_CommonEventImplementations
	local ContainerPatternNames = utils_storage_patterns_ContainerPatternNames
	local TreeFarmCodedInventoryListeners = jobs_definitions_mobile_treeFarm_TreeFarmCodedInventoryListeners
	local Job = jobs_Job
	local LogProtocol = utils_network_protocols_logging_LogProtocol
	local Turtle = turtle_Turtle
	local Me = utils_other_Me
	local PlayerProtocol = utils_network_protocols_remoteperipherals_PlayerProtocol
	local FollowerStates = jobs_definitions_mobile_follower_FollowerStates
	local FollowerJob = {}
	FollowerJob.__index = FollowerJob
	FollowerJob.name = Job.FOLLOWER_JOB
	function FollowerJob.new(config)
	    local self = setmetatable({}, FollowerJob)
	    self.modules = {}
	    self.backgroundTasks = {
	    }
	    self.commands = Commands.new()
	    self.commands:add(Command.new("exit", "Terminates the program", function(...) CommonCommands.commandExit(self, ...) end))
	    self.commands:add(Command.new("start", "Starts the program", function(...) TreeFarmCommands.commandTreeFarmStart(self, ...) end))
	    self.config = config
	    self.states = {
	        COMMAND_PROMPT = "COMMAND_PROMPT",
	        MOVING_TO_TARGET = "MOVING_TO_TARGET",  -- Turtle moves to the target and stops when it is at it
	        FOLLOWING_TARGET = "FOLLOWING_TARGET",  -- Turtle follows the target and stays within a certain distance
	        FINDING_TARGET = "FINDING_TARGET",
	        IDLE = "IDLE",  -- Turtle is not moving - waiting for target to move
	        ATTACKING_TARGET = "ATTACKING_TARGET",  -- Turtle attacks the target
	    }
	    self.stateActions = {
	        [self.states.COMMAND_PROMPT] = CommonStates.onCommandPrompt,
	        [self.states.FOLLOWING_TARGET] = FollowerStates.onFollowingTarget,
	    }
	    self.codedInventory = CodedInventory.new()
	    self.codedInventory:addDefaultListeners()
	    self.codedInventory:addListener(ContainerPatternNames.ACTION_HOME, TreeFarmCodedInventoryListeners.actionHome)
	    self.codedInventory:addListener(ContainerPatternNames.ACTION_MOVE, TreeFarmCodedInventoryListeners.actionMove)
	    self.codedInventory:addListener(ContainerPatternNames.ACTION_DROP, TreeFarmCodedInventoryListeners.actionDrop)
	    self.codedInventory:addListener(ContainerPatternNames.ACTION_SUCK, TreeFarmCodedInventoryListeners.actionSuck)
	    self.codedInventory:addListener(ContainerPatternNames.ACTION_REFUEL, TreeFarmCodedInventoryListeners.actionRefuel)
	    self.protocols = {
	        log = LogProtocol.new(self),
	        player = PlayerProtocol.new(self),
	    }
	    return self
	end
	function FollowerJob:onStart()
	    self.config:set("targetPlayer", Me.username)
	    self.config:set("state", self.states.FOLLOWING_TARGET)
	    return CommonEventImplementations.onStart(self)
	end
	function FollowerJob:onResume()
	    return CommonEventImplementations.onResume(self)
	end
	function FollowerJob:inProgress()
	    if Turtle.getFuelLevel() < 512 then
	        self.log("Fuel level is low.")
	        self.log("Location is: " .. Turtle.CURRENT_POSITION:__tostring())
	        self.config:set("state", self.states.COMMAND_PROMPT)
	    end
	    return CommonEventImplementations.inProgress(self)
	end
	function FollowerJob:onStep()
	    return CommonEventImplementations.onStepMobile(self)
	end
	function FollowerJob:onComplete()
	    return CommonEventImplementations.onComplete(self)
	end
	return FollowerJob
end
local jobs_definitions_mobile_follower_FollowerJob = MODULE_jobs_definitions_mobile_follower_FollowerJob()


function MODULE_entrypoints_follower()
	local JobManager = jobs_JobManager
	local FollowerJob = jobs_definitions_mobile_follower_FollowerJob
	JobManager.run(FollowerJob)
end
local entrypoints_follower = MODULE_entrypoints_follower()